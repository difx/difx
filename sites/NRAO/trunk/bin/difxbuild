#!/bin/env python

from os import environ, system, getcwd, chdir, popen
from os.path import isdir, isfile, islink, join, dirname
from sys import argv, exit, platform
from re import search
import getopt
from string import split, strip, find
from platform import machine

openmpiVersion = "1.6"
numMakeCpus = 4


def getippversion(path):
	if islink(path):
		path = join(dirname(path), readlink(path))
# First try ippversion.h
        ippheader = path+'/include/ippversion.h'
	if not isfile(ippheader):
		ippheader = path+'/ipp/include/ippversion.h'
		if not isfile(ippheader):
			ippheader = ''

	if (ippheader==''):
		print "Warning: ippversion.h not found, relying on IPP path ", path
		s = split(path, '/')
		possibilities = []
		for part in s:
			t = split(part, '.')
			if len(t) > 1:
				possibilities.append(part)
				if len(possibilities) < 1:
					print 'Sorry, cannot determine ipp version from path'
					exit(0)
					if len(possibilities) > 1:
						print 'Guessing version == %s' % possibilities[-1]

						return possibilities[-1]
					
	else:
		print "Reading version from ", ippheader
		major = minor = None
		for line in open(ippheader):
			m = search('#define\s+IPP_VERSION_STR\s+"(\S+)"', line)
			if (m != None):
				print "Got version ", m.group(1)
				return m.group(1)
			if (major == None):
			    major = search('#define\s+IPP_VERSION_MAJOR\s+(\S)', line)
			if (minor == None):
			    minor = search('#define\s+IPP_VERSION_MINOR\s+(\S)', line)
		if (major != None and minor != None):
			print "Have version ", major.group(1) + "." + minor.group(1)
			return major.group(1) + "." + minor.group(1)
		print "Sorry, cannot find IPP_VERSION_STR in ", ippheader
		exit(0)
	
# fixme: possibly should use uname to get this information
def getarch():
	bs = environ['DIFXBITS']
	if bs != None:
		return int(bs)
	else:
		print 'Warning: defaulting to 32 bit assumption'
		return 32

def genipppc(path):
	ippversion = getippversion(path)
	ipparch = getarch()

	major = int(split(ippversion, '.')[0])
	out = open('ipp.pc', 'w')
	out.write('base = %s\n' % path)
	out.write('\n')
	out.write('Name: ipp\n')
	out.write('Description: Intel Performance Primitives\n')
	out.write('Requires:\n')
	out.write('Version: %s\n' % ippversion)
	
	mac = False
	if platform == "darwin":
		mac = True

	if major == 6 or major == 5:
		if mac:
			libdir = 'Libraries'
		else:
			libdir = 'sharedlib'
		if ipparch == 32:
			out.write('Libs: -Wl,-rpath,${base}/%s -L${base}/%s -lipps -lguide -lippvm -lippcore\n' % (libdir, libdir))
			out.write('Cflags: -I${base}/include\n')
		else:
			out.write('Libs: -Wl,-rpath,${base}/%s -L${base}/%s -lippsem64t -lguide -lippvmem64t -lippcoreem64t\n' % (libdir, libdir))
			out.write('Cflags: -I${base}/include\n')
	elif major == 7:
		if ipparch == 32:
			libdir = 'ia32'
		else:
			libdir = 'intel64'
		out.write('Libs: -L${base}/lib/%s -L${base}/ipp/lib/%s -lipps -lippvm -lippcore -liomp5\n' % (libdir, libdir))
		out.write('Cflags: -I${base}/ipp/include\n')

	else:
		print 'Sorry, IPP %d not yet supported by this script\n' % major

	out.close()

nExecute = 0
def execute(cmd, verbose, pretend):
	global nExecute
	nExecute += 1
	if pretend:
		print '%s# %s' % (getcwd(), cmd)
	else:
		if verbose:
			print '[%d] In: %s   Executing: %s' % (nExecute, getcwd(), cmd)
		system(cmd)

def checkDirs(comps, dir, args):
	okComps = []
	for comp in comps:
		path = dir + comp[0] + '/'
		if not isdir(path):
			if 'ok' in args:
				print 'Warning: %s does not exist.  Skipping.' % path
			else:
				print 'Error: %s does not exist.  Stopping.' % path
		else:
			okComps.append(comp)

	if not 'ok' in args and len(comps) != len(okComps):
		okComps = []

	return okComps

def checkFiles(comps, dir, fileName, args):
	okComps = []
	for comp in comps:
		file = dir + comp[0] + '/' + fileName
		if not isfile(file):
			if 'ok' in args:
				print 'Warning: %s does not exist.  Skipping.' % file
			else:
				print 'Error: %s does not exist.  Stopping.' % file
		else:
			okComps.append(comp)

	if not 'ok' in args and len(comps) != len(okComps):
		okComps = []

	return okComps

def componentList(comps):
	i = 0
	str = ''
	for c in comps:
		if i > 0:
			str += ', '
		str += c[0]
		i += 0
	return str

def filterComponents(origComps, args):
	if 'cwd' in args:
		local = split(getcwd(), '/')[-2:]
	else:
		local = []
	
	comps = []
	for c in origComps:
		if c[0] in local or c[0] in args:
			comps.append(c)
	if len(comps) == 0:
		if 'cwd' in args:
			print "Error: cannot build in local directory: don't know where I am!"
		else:
			comps = origComps
	return comps

components = {}	# indexed by ${DIFX_VERSION}

# components each have the following elements:
# [
#	0 name
#	1 svn path
#	2 [build flags]
# ]

component_difxio_trunk = \
[ \
	'difxio', \
	'https://svn.atnf.csiro.au/difx/libraries/difxio/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'spice'] \
]

component_difxmessage_trunk = \
[ \
	'difxmessage', \
	'https://svn.atnf.csiro.au/difx/libraries/difxmessage/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'] \
]

component_mark5access_trunk = \
[ \
	'mark5access', \
	'https://svn.atnf.csiro.au/difx/libraries/mark5access/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'] \
]

component_vdifio_trunk = \
[ \
	'vdifio', \
	'https://svn.atnf.csiro.au/difx/libraries/vdifio/trunk', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'] \
]

component_mpifxcorr_trunk = \
[ \
	'mpifxcorr', \
	'https://svn.atnf.csiro.au/difx/mpifxcorr/trunk', \
	['aclocal', 'autoconf', 'autoheader', 'automake', 'mpicxx', 'ipp'] \
]

component_difx2fits_trunk = \
[ \
	'difx2fits', \
	'https://svn.atnf.csiro.au/difx/applications/difx2fits/trunk' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_difx2mark4_trunk = \
[ \
	'difx2mark4', \
	'https://svn.atnf.csiro.au/difx/applications/difx2mark4/trunk' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_vex2difx_trunk = \
[ \
	'vex2difx', \
	'https://svn.atnf.csiro.au/difx/applications/vex2difx/trunk' ,\
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'] \
]

component_calcif2_trunk = \
[ \
	'calcif2', \
	'https://svn.atnf.csiro.au/difx/utilities/trunk/calcif2' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_calcserver_trunk = \
[ \
	'calcserver', \
	'https://svn.atnf.csiro.au/difx/applications/calcserver/trunk', \
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_rcwlib_trunk = \
[ \
	'rcwlib', \
	'https://svn.atnf.csiro.au/difx/sites/NRAO/trunk/rcwlib', \
	['aclocal', 'libtoolize', 'autoconf', 'automake'] \
]

component_sniff_trunk = \
[ \
	'SniffPlots', \
	'https://svn.atnf.csiro.au/difx/sites/NRAO/trunk/SniffPlots', \
	['aclocal', 'autoconf', 'automake'] \
]

components['DIFX-DEVEL'] = \
[ \
	component_difxio_trunk, \
	component_difxmessage_trunk, \
	component_mark5access_trunk, \
	component_vdifio_trunk, \
	component_mpifxcorr_trunk, \
	component_difx2fits_trunk, \
	component_difx2mark4_trunk, \
	component_vex2difx_trunk, \
	component_calcif2_trunk, \
	component_calcserver_trunk, \
	component_rcwlib_trunk, \
	component_sniff_trunk, \
]

component_difxio_2_1 = \
[ \
	'difxio', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/libraries/difxio', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake', 'spice'] \
]

component_difxmessage_2_1 = \
[ \
	'difxmessage', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/libraries/difxmessage', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'] \
]

component_mark5access_2_1 = \
[ \
	'mark5access', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/libraries/mark5access', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'] \
]

component_vdifio_2_1 = \
[ \
	'vdifio', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/libraries/vdifio', \
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'] \
]

component_mpifxcorr_2_1 = \
[ \
	'mpifxcorr', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/mpifxcorr', \
	['aclocal', 'autoconf', 'autoheader', 'automake', 'mpicxx', 'ipp'] \
]

component_difx2fits_2_1 = \
[ \
	'difx2fits', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/difx2fits' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_difx2mark4_2_1 = \
[ \
	'difx2mark4', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/difx2mark4' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_vex2difx_2_1 = \
[ \
	'vex2difx', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/vex2difx' ,\
	['aclocal', 'libtoolize', 'autoconf', 'autoheader', 'automake'] \
]

component_calcif2_2_1 = \
[ \
	'calcif2', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/calcif2' ,\
	['aclocal', 'autoconf', 'autoheader', 'automake'], \
]

component_calcserver_2_1 = \
[ \
	'calcserver', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/applications/calcserver', \
	['aclocal', 'autoconf', 'autoheader', 'automake'] \
]

component_rcwlib_2_1 = \
[ \
	'rcwlib', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/sites/NRAO/rcwlib', \
	['aclocal', 'libtoolize', 'autoconf', 'automake'] \
]

component_sniff_2_1 = \
[ \
	'SniffPlots', \
	'https://svn.atnf.csiro.au/difx/master_tags/DiFX-2.1/sites/NRAO/SniffPlots', \
	['aclocal', 'autoconf', 'automake'] \
]

components['DIFX-2.1'] = \
[ \
	component_difxio_2_1, \
	component_difxmessage_2_1, \
	component_mark5access_2_1, \
	component_vdifio_2_1, \
	component_mpifxcorr_2_1, \
	component_difx2fits_2_1, \
	component_difx2mark4_2_1, \
	component_vex2difx_2_1, \
	component_calcif2_2_1, \
	component_calcserver_2_1, \
	component_rcwlib_2_1, \
	component_sniff_2_1, \
]

# commands each have the following elements:
# [
#	0 Name
#	1 Description
#	2 Needed env variables
#	3 Command line values
#	4 Function to call
# ]

def list(comps, params, args, verbose, pretend):
	print 'Components being managed for %s are:' % environ['DIFX_VERSION']
	for c in comps:
		print '  %s' % c[0]
	print ''

def default(comps, params, args, verbose, pretend):
	execute('rm %s/bin/setup_difx' % environ['DIFX_BASE'], verbose, pretend)
	if isfile('%s/bin/setup_difx' % environ['DIFX_BASE']):
		print 'Error: could not unlink existing DiFX version'
		exit(2)
	execute('ln -s %s/setup_difx %s/bin' % (environ['DIFXROOT'], environ['DIFX_BASE']), verbose, pretend)
	if not isfile('%s/bin/setup_difx' % environ['DIFX_BASE']):
		print 'Error: could not link new DiFX version.  NO version is default now!'
		exit(2)
	print 'New default version of DiFX selected.'
	print 'Make sure ". %s/bin/setup_difx" is in your .bashrc file' % environ['DIFX_BASE']

def splitequals(str):
	p = find(str, '=')
	if p < 0:
		return [str]
	else:
		return [strip(str[:p]), strip(str[p+1:])]

def bootstrap(comps, params, args, verbose, pretend):
	if not isfile(params['ConfigFile']):
		print 'Error: bootstrapping needs the specified configuration file, %s, to exist.' % params['ConfigFile']
		return
	configData = open(params['ConfigFile'], 'r').readlines()
	config = {}
	env = {}
	for c in configData:
		c = split(c, '#')[0]	# strip comments
		s = splitequals(strip(c))
		if len(s) == 2:
			t = split(s[0])
			if len(t) == 1:
				config[strip(s[0])] = strip(s[1])
			elif len(t) == 2:
				if t[0] == 'env':
					env[strip(t[1])] = strip(s[1])
				else:
					print 'Error: line %s is not understood' % c
					return
			else:
				print 'Error: line %s is not understood' % c
				return
	
	if verbose > 0:
		print 'Config:'
		for c in config.keys():
			print '  %s = %s' % (c, config[c])
		print 'Environment:'
		for e in env.keys():
			print '  %s = %s' % (e, env[e])

	try:
		setupFile = config['root'] + '/setup_difx'
		if verbose > 0:
			print 'Writing setup file %s' % setupFile

		dirs = [config['root'], '%s/directories' % config['difxbase'], '%s/bin/' % environ['DIFX_BASE']]
		for d in dirs:
			if not isdir(d):
				execute('mkdir -p %s' % d, verbose, pretend)

		platforms = {}
		platforms[machine()] = []
		for i in range(1, 10):
			if not config.has_key('altplatform%d' % i):
				break;
			aarch = config['altplatform%darch' % i]
			if not aarch in platforms:
				platforms[aarch] = []
			platforms[aarch].append([config['altplatform%d' % i], config['altplatform%dtest' % i]])

		if config.has_key('mca'):
			print 'Making .openmpi/mca-params.conf'
			execute('mkdir -p %s/.openmpi' % environ['HOME'], verbose, pretend)
			out = open('%s/.openmpi/mca-params.conf' % environ['HOME'], 'w')
			out.write('%s\n' % config['mca'])
			out.close()


		out = open('%s/bin/runmpifxcorr.%s' % (config['difxbase'], config['version']), 'w')
		out.write('#!/bin/bash\n\n')
		out.write('. %s/bin/%s\n' % setupFile)
		if config.has_key('wrapper'):
			out.write('%s ' % config['wrapper'])
		out.write('mpifxcorr $@\n')
		out.close()
		
		out = open(setupFile, 'w')
		
		out.write('#!/bin/bash\n\n')
		out.write('# DiFX setup file automatically generated by difxbuild\n\n')
		out.write('DIFX_PROMPT_EXTRA=""\n')
		out.write('HWPLATFORM=`uname --processor`\n')
		out.write('\n')
		out.write('export DIFX_ARCH_ROOT=%s/${HWPLATFORM}\n' % config['difxbase'])
		for arch in platforms.keys():
			out.write('if [[ ${HWPLATFORM} = "%s" ]]; then\n' % arch)
			if arch in ['x86_64']:
				out.write('  export DIFXBITS=64\n')
				out.write('  export IPPARCH=intel64\n')
			elif arch in ['i386', 'i686']:
				out.write('  export DIFXBITS=32\n')
				out.write('  export IPPARCH=ia32\n')
			n = 0
			for plat in platforms[arch]:
				if n == 0:
					out.write('  if')
				else:
					out.write('  elif')
				n += 1
				out.write(' %s; then\n' % plat[1])
				out.write('    export DIFXROOT=%s-%s\n' % (config['root'], plat[0]))
				out.write('    DIFX_PROMPT_EXTRA="${DIFX_PROMPT_EXTRA} %s"\n' % plat[0])
			if arch == machine():
				if n > 0:
					out.write('  else\n')
					out.write('    export DIFXROOT=%s\n' % config['root'])
					out.write('  fi\n')
				else:
					out.write('  export DIFXROOT=%s\n' % config['root'])
			else:
				out.write('  fi\n')
					
			out.write('fi\n')
		out.write('export DIFX_SRC=%s/src\n' % config['root'])
		out.write('export IPPROOT=%s\n' % config['ipproot'])
		out.write('export X11LIBS=-lX11\n')
		out.write('export CALC_SERVER=%s\n' % config['calcserver'])
		out.write('export DIFX_HEAD_NODE=%s\n' % config['headnode'])
		out.write('export DIFX_BASE=%s\n' % config['difxbase'])
		if not env.has_key('CFLAGS'):
			out.write('export CFLAGS="-O2 -Wall -march=core2"\n')
		if not env.has_key('CXXFLAGS'):
			out.write('export CXXFLAGS="-O2 -Wall -march=core2"\n')
		out.write('export MPICXX=${DIFX_ARCH_ROOT}/bin/mpicxx\n')
		out.write('export PKG_CONFIG_PATH=${DIFXROOT}/lib/pkgconfig\n')
		out.write('export MARK5_DIR_PATH=${DIFX_BASE}/directories\n')
		out.write('export DIFX_VERSION=%s\n' % config['version'])
		if not env.has_key('DIFX_MESSAGE_GROUP'):
			out.write('export DIFX_MESSAGE_GROUP=224.2.2.1\n')
		if not env.has_key('DIFX_MESSAGE_PORT'):
			out.write('export DIFX_MESSAGE_PORT=50200\n')

		out.write('\n')
		out.write('export PATH=${DIFX_ARCH_ROOT}/bin:${DIFXROOT}/bin:~/bin:/bin:/usr/bin\n')
		out.write('export LD_LIBRARY_PATH=${DIFX_ARCH_ROOT}/lib:/lib:/usr/lib:${DIFXROOT}/lib:${IPPROOT}/${IPPARCH}/ipp/lib/${IPPARCH}:${IPPROOT}/${IPPARCH}/lib/${IPPARCH}\n')

		for e in env.keys():
			out.write('export %s=%s\n' % (e, env[e]))

		out.write("alias src='cd ${DIFX_SRC}'\n")
		out.write("alias bld='cd ${DIFX_PREFIX}/build'\n")

		out.close()

		print '\nBootstrap complete.  Now source %s and continue with svn.\n' % setupFile

	except KeyError:
		print 'Parse error'


def svnupdate(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	srcDir = environ['DIFX_SRC'] + '/'
	if not isdir(srcDir):
		execute('mkdir -p %s' % srcDir, verbose, pretend);
		
	for comp in comps:
		path = srcDir + comp[0] + '/'
		if isdir(path):
			chdir(path)
			cmd = 'svn update'
		else:
			chdir(srcDir)
			cmd = 'svn co %s %s' % (comp[1], comp[0])
		execute(cmd, verbose, pretend)

def autotool(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	srcDir = environ['DIFX_SRC'] + '/'
	okComps = checkDirs(comps, srcDir, args)
	if verbose > 1:
		print 'Autotooling: %s' % componentList(okComps)
	for comp in okComps:
		path = srcDir + comp[0] + '/'
		chdir(path)
		buildFlags = comp[2]
		if 'aclocal' in buildFlags:
			execute('aclocal', verbose, pretend)
		if 'libtoolize' in buildFlags:
			execute('libtoolize --copy --force', verbose, pretend)
		if 'autoconf' in buildFlags:
			execute('autoconf', verbose, pretend)
		if 'autoheader' in buildFlags:
			execute('autoheader', verbose, pretend)
		if 'automake' in buildFlags:
			execute('automake -a', verbose, pretend)

def build(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	buildDir = environ['DIFXROOT'] + '/build/'
	pkgDir = environ['DIFXROOT'] + '/lib/pkgconfig/'
	srcDir = environ['DIFX_SRC'] + '/'
	okComps = checkFiles(comps, srcDir, 'configure', args)
	if len(okComps) > 0:
		if verbose > 1:
			print 'Generating ipp.pc'
		if not isdir(pkgDir):
			execute('mkdir -p %s' % pkgDir, verbose, pretend)
		chdir(pkgDir)
		genipppc('%s/%s' % (environ['IPPROOT'], environ['IPPARCH']))
		if verbose > 1:
			print 'Building: %s' % componentList(okComps)
		if not isdir(buildDir):
			execute('mkdir -p %s' % buildDir, verbose, pretend)
		for comp in okComps:
			srcPath = srcDir + comp[0] + '/'
			buildPath = buildDir + comp[0] + '/'
			if not isdir(buildPath):
				execute('mkdir -p %s' % buildPath, verbose, pretend)
			chdir(buildPath)
			if not 'noconf' in args:
				buildFlags = comp[2]
				configureExtras = ''
				if 'mpicxx' in buildFlags:
					configureExtras += ' CXX=${MPICXX}'
				if 'spice' in buildFlags:
					spiceRoot = environ['DIFX_BASE'] + '/' + machine() + '/cspice/'
					if isfile(spiceRoot+'lib/cspice.a'):
						print 'Spice library found!'
						configureExtras += ' --with-spice-root=' + spiceRoot
					else:
						print 'Spice library %slib/cspice.a not found' % spiceRoot
						if 'strict' in args:
							print 'Bailing'
							exit(2)
						else:
							print 'Continuing anyway'	
				cmd = '%s/configure --prefix=${DIFXROOT}%s' % (srcPath, configureExtras)
				execute(cmd, verbose, pretend)
			execute('make -j %d' % numMakeCpus, verbose, pretend)
			execute('make install', verbose, pretend)
			
def rebuild(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	buildDir = environ['DIFXROOT'] + '/build/'
	okComps = checkFiles(comps, buildDir, 'Makefile', args)
	if verbose > 1:
		print 'Rebuilding: %s' % componentList(okComps)
	for comp in okComps:
		buildPath = buildDir + comp[0] + '/'
		if isdir(buildPath):
			chdir(buildPath)
			execute('make -j %d' % numMakeCpus, verbose, pretend)
			execute('make install', verbose, pretend)
			
def uninstall(origComps, params, args, verbose, pretend):
	comps = filterComponents(origComps, args)
	buildDir = environ['DIFXROOT'] + '/build/'
	okComps = checkFiles(comps, buildDir, 'Makefile', args)
	okComps.reverse()	# best done in reverse for reasons of dependency
	if verbose > 1:
		print 'Uninstalling: %s' % componentList(okComps)
	for comp in okComps:
		buildPath = buildDir + comp[0] + '/'
		if isdir(buildPath):
			chdir(buildPath)
			execute('make uninstall', verbose, pretend)

def remove(origComps, params, args, verbose, pretend):
	print 'Feature not yet implemented'

def spice(origComps, params, args, verbose, pretend):
	arch = machine()
	if arch == 'x86_64':
		spiceUrl = 'ftp://naif.jpl.nasa.gov/pub/naif/toolkit//C/PC_Linux_GCC_64bit/packages/cspice.tar.Z'
	elif arch == 'i386':
		spiceUrl = 'ftp://naif.jpl.nasa.gov/pub/naif/toolkit//C/PC_Linux_GCC_32bit/packages/cspice.tar.Z'
	difxBase = environ['DIFX_BASE'] + '/'
	tarDir = difxBase + 'tar/'
	if not isdir(tarDir):
		execute('mkdir -p %s' % tarDir, verbose, pretend)
	if not isfile(tarDir + 'cspice.tar.Z'):
		chdir(tarDir)
		execute('wget %s' % spiceUrl, verbose, pretend)
	else:
		print 'Spice file already downloaded.'
	if not isdir(difxBase + arch):
		execute('mkdir -p %s%s' % (difxBase, arch), verbose, pretend)
	chdir(difxBase + arch)
	execute('tar zxvf %s/cspice.tar.Z' % tarDir, verbose, pretend)

def openmpi(origComps, params, args, verbose, pretend):
	openmpiWeb = 'http://www.open-mpi.org/software/ompi/v%s/downloads' % openmpiVersion
	difxBase = environ['DIFX_BASE'] + '/'
	tarDir = difxBase + 'tar/'
	cpuDir = difxBase + machine() + '/'
	cpuSrcDir = cpuDir + 'src/'
	if not isdir(tarDir):
		execute('mkdir -p %s' % tarDir, verbose, pretend)
	if not isdir(cpuSrcDir):
		execute('mkdir -p %s' % cpuSrcDir, verbose, pretend)
	openmpiFiles = popen('wget %s/md5sums.txt -O - | grep stable.tar.bz2' % openmpiWeb, 'r').readlines()
	if len(openmpiFiles) != 1:
		print "I'm confused: expecting one stable.tar.bz2 file in %s/md5sums.txt, but found %d" % (len(openmpiFiles), openmpiWeb)
		return
	goodsum = split(strip(openmpiFiles[0]))[0]
	openmpiTarFile = split(strip(openmpiFiles[0]))[1]
	download = True
	if isfile(tarDir+openmpiTarFile):
		sum = split(popen('md5sum %s%s' % (tarDir, openmpiTarFile), 'r').readline())[0]
		if sum != goodsum:
			print 'Old or corrupt file %s.  File is being moved to /tmp' % (tarDir+openmpiTarFile)
			execute('mv %s%s /tmp' % (tarDir, openmpiTarFile), verbose, pretend)
		else:
			print 'Existing file %s%s looks OK' % (tarDir, openmpiTarFile)
			download = False
	if download:
		chdir(tarDir)
		execute('wget %s/%s' % (openmpiWeb, openmpiTarFile), verbose, pretend)
		sum = split(popen('md5sum %s%s' % (tarDir, openmpiTarFile), 'r').readline())[0]
		if sum != goodsum:
			print 'Newly downloaded file %s%s does not match expected md5sum %s' % (openmpiWeb, openmpiTarFile, goodsum)
			return
	# get ompi src dir
	openmpiSrcDir = cpuSrcDir + strip(popen('tar tjf %s%s' % (tarDir, openmpiTarFile), 'r').readline())
	if isdir(openmpiSrcDir):
		print '%s already untarred in %s; assuming this is a good copy' % (openmpiTarFile, cpuSrcDir)
	else:
		chdir(cpuSrcDir)
		execute('tar jxvf %s%s' % (tarDir, openmpiTarFile), verbose, pretend)
	chdir(openmpiSrcDir)
	execute('./configure --prefix=%s --enable-heterogeneous' % cpuDir, verbose, pretend)
	execute('make -j %d' % numMakeCpus, verbose, pretend)
	execute('make install', verbose, pretend)



command_list = \
[ \
	'list', \
	'List the components managed by this script for this DiFX version', \
	[], \
	[], \
	list \
]

command_default = \
[ \
	'default', \
	'Set the default version of DiFX to that identified in the current environment', \
	['DIFXROOT', 'DIFX_BASE'], \
	[], \
	default \
]

command_bootstrap = \
[ \
	'bootstrap', \
	'Begin installation process for one DiFX Version', \
	['HOME'], \
	['ConfigFile'], \
	bootstrap \
]

command_svn = \
[ \
	'svn', \
	'Checkout or update from svn repository', \
	['DIFX_SRC'], \
	[], \
	svnupdate \
]

command_autotool = \
[ \
	'autotool', \
	'Prepare source directories for configuring', \
	['DIFX_SRC'], \
	[], \
	autotool \
]

command_build = \
[ \
	'build', \
	'Run configure for each component then build/install', \
	['DIFX_SRC', 'DIFXROOT', 'MPICXX', 'PKG_CONFIG_PATH', 'DIFXBITS', 'IPPROOT', 'IPPARCH'], \
	[], \
	build \
]

command_rebuild = \
[ \
	'rebuild', \
	'Build/install each component', \
	['DIFX_SRC', 'DIFXROOT'], \
	[], \
	rebuild \
]

command_uninstall = \
[ \
	'uninstall', \
	'Uninstall each component but leave source and build directories in tact', \
	['DIFXROOT'], \
	[], \
	uninstall \
]

command_remove = \
[ \
	'remove', \
	'Uninstall each component and remove source and build directories', \
	['DIFX_SRC', 'DIFXROOT'], \
	[], \
	remove \
]

command_spice = \
[ \
	'spice', \
	'Download (if needed) and install spice', \
	['DIFX_BASE'], \
	[], \
	spice \
]

command_openmpi = \
[ \
	'openmpi', \
	'Download (if needed), compile, and install openmpi version %s' % openmpiVersion, \
	['DIFX_BASE'], \
	[], \
	openmpi \
]

commands = \
[ \
	command_list, \
	command_bootstrap, \
	command_default, \
	command_svn, \
#	command_tar, \
	command_autotool, \
	command_openmpi, \
	command_spice, \
	command_build, \
	command_rebuild, \
	command_uninstall, \
#	command_remove, \
]


def run_command(commandName, args, verbose, pretend):
	command = None
	for c in commands:
		if c[0] == commandName:
			command = c
	if not command == None:
		hasEnviron = True
		hasParams = True
		for e in command[2]:
			if not environ.has_key(e):
				print 'Env. Var. %s needs to be set' % e
				hasEnviron = False
		nParam = len(command[3])
		params = {}
		if len(args) < nParam:
			print 'Two few arguments provided'
			hasParams = False
		else:
			for i in range(nParam):
				params[command[3][i]] = args[i]
		if hasEnviron and hasParams:
			if verbose > 1:
				print '  params=', params
				print '  extras=', args[nParam:]
				print '  pretend=', pretend
				print '  verbose=', verbose
				print ''
			print '=== Running command: %s ===\n' % command[0]
			if command[0] == 'bootstrap':
				comps = []
			else:
				comps = components[environ['DIFX_VERSION']]
			command[4](comps, params, args[nParam:], verbose, pretend)
		else:
			print 'Not going to run.'
			
	else:
		print 'Command "%s" not recognized.  Seek help.' % commandName


def usage(prog):
	print 'usage:  %s [options] <command> [<command arguments>]\n' % prog
	print 'The possible commands are:\n'
	for command in commands:
		extras = ''
		for c in command[3]:
			extras = extras + ' <' + c + '>'
		print '%s%s' % (command[0], extras)
		print '  %s\n' % command[1]
	
	print '\nCurrently the following key variables are set:'
	vars = ['DIFXROOT', 'DIFX_BASE', 'DIFX_ARCH_ROOT']
	for v in vars:
		if environ.has_key(v):
			print '%s = %s' % (v, environ[v])
		else:
			print '%s is unset' % v

def main():
	try:
		opts, args = getopt.getopt(argv[1:], "hqvp", ["help", "quiet", "verbose", "pretend"])
	except getopt.GetoptError, err:
		print '%s\n' % str(err)
		usage(argv[0])
		exit(2)
	verbose = 1
	pretend = False
	for o, a in opts:
		if o == '-v':
			verbose += 1
		elif o == '-q':
			verbose -= 1
		elif o == '-h':
			usage(argv[0])
			exit(0)
		elif o == '-p':
			pretend = True

	if len(args) <= 0:
		usage(argv[0])
		exit(0)
		
	if args[0] != 'bootstrap':
		if not environ.has_key('DIFX_VERSION'):
			print 'Env. Var. DIFX_VERSION needs to be set'
			exit(2)
		if not components.has_key(environ['DIFX_VERSION']):
			print 'This script is not set up to handle version %s' % environ['DIFX_VERSION']
			exit(2)

	run_command(args[0], args[1:], verbose, pretend)

#----

if __name__ == "__main__":
	main()
