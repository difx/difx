#!/usr/bin/env python

from sys import argv, exit
from string import strip, split, find, lower, upper
from math import pi, ceil
from os import getcwd, system, getenv, umask
import re

program = 'job2difx'
version = '1.11'
verdate = '20080717'
author  = 'Walter Brisken'

# TODO: choose the following with more smarts
BufferFactor = 32
NDataSegment = 8
MaxEOP = 5
verbose = 0
multiconfig = 0
visbufferlength = 32
spectrunc = 2	# do this much spectral truncation before doing decimation

def usage():
	print '\n%s ver. %s   %s %s' % (program, version, verdate, author)
	print '\nA program to convert one or more VLBA correlator job scripts'
	print 'to various DiFX input files.  Attempts are made to generate'
	print 'output files as similar as possible to the VLBA output'
	print '\nUsage: %s [options] <job file>' % (argv[0])
	print '\nOptions can include:'
	print '\n  -h or --help            print this help into and exit'
	print '\n  -s or --single-config   allow only 1 config per job [default]'
	print '\n  -p or --multi-pass      handle multiple configs in passes'
	print '\n  -m or --multi-config    multiple configs per job [flakey]'
	print '\n  -v or --verbose         spew lots of info to the screen'
	print '\n  List of antennas : e.g.  A=BR,KP,LA'
	print '    Multiple antenna lists are appended, e.g.  A=BR A=KP A=LA'
	print '    Default is all antennas in job'
	print '\n  Number of channels : e.g.  nchan=32'
	print '\n  FFT size : e.g.  fftsize=128'
	print '\n  Integration time : e.g.  tint=0.5'
	print '\n  Minimum subarray size : e.g.  minsub=5'
	print '\n  Amount of spectral truncation to perform before decimation :'
	print   '      e.g.  spectrunc=4      legal values are 1, 2, 4, 8, 16\n'
	exit(0)

##### Functions that do parsing #######

# return mjd from string of form 2007FEB09_11h58m41s
def parsetime(str):
	ms = {'JAN':0,  'FEB':31, 'MAR':59, 'APR':90, 'MAY':120,'JUN':151, \
	      'JUL':181,'AUG':212,'SEP':243,'OCT':273,'NOV':304,'DEC':334}
	year = int(str[0:4])
	mon = str[4:7]
	day = int(str[7:9])
	h = int(str[10:12])
	m = int(str[13:15])
	s = int(str[16:18])
	ly = year/4-(year+7)/4-year/100+(year+99)/100+year/400-(year+399)/400
	doy = ms[mon]
	if ly == -1 and doy > 40:
		doy += 1	# leap year
	doy += day
	
	mjd = doy-678576+365*(year-1)+(year-1)/4-(year-1)/100+(year-1)/400

	return mjd + h/24.0 + m/1440.0 + s/86400.0


def mjd2calendar(mjd):
	jd = int(mjd)+2400000
	l = jd + 68570
	n = 4*l/146097
	l = l - (146097*n + 3)/4
	y = 4000 * (l + 1) / 1461001
	l = l - (1461*y)/4 + 31
	m = 80*l/2447
	day = l - (2447*m)/80
	l = m/11
	month = m + 2 - 12*l
	year = 100*(n-49) + y + l

	d = mjd - int(mjd)
	d = d*24.0
	hour = int(d)
	d = 60.0*(d - hour)
	minute = int(d)
	d = 60.0*(d - minute)
	second = int(d+0.5)

	return [year,month,day,hour,minute,second]

def RA2radians(rastr):
	ra_re = re.compile('[hms]')
	parts = split(strip(ra_re.sub(' ', rastr)))
	h = int(parts[0])
	m = int(parts[1])
	s = float(parts[2])

	return (h+m/60.0+s/3600.0)*pi/12.0

def Dec2radians(decstr):
	dec_re = re.compile("""[d'"]""")
	parts = split(strip(dec_re.sub(' ', decstr)))
	if parts[0][0] == '-':
		sign = -1.0
	else:
		sign = 1.0
	d = abs(int(parts[0]))
	m = int(parts[1])
	s = float(parts[2])

	return sign*(d+m/60.0+s/3600.0)*pi/180.0


# turn an array of form (ind1,val1,ind2,val2,ind3,val3,...) into val[ind]
def parsearray(str):
	list = strip(str)
	if list[0] != '(' or list[-1] != ')':
		return []
	s = split(list[1:-1], ',')
	n = len(s)
	if n % 2 == 1:
		return []
	max = 0
	for i in range(0,n,2):
		index = int(strip(s[i]))
		if index < 0:
			return []
		if index > max:
			max = index
	arr = [0]*(max+1)
	for i in range(0,n,2):
		index = int(strip(s[i]))
		arr[index] = strip(s[i+1])
	
	return arr

def parsevalue(row, token):
	s = split(token, '=')
	if len(s) == 2:
		val = strip(s[1])
		if len(val) < 1:
			row[strip(s[0])] = ''
		elif val[0] == "'":
			row[strip(s[0])] = strip(s[1])[1:-1]
		elif val[0] == '(':
			row[strip(s[0])] = parsearray(val)
		else:
			row[strip(s[0])] = val

# this function makes extensive use of regular expressions to parse
# a cjobgen job file into a structured dictionary(table) of lists(row) of
# dictionaries(parameter).  If this function doesn't make sense to you,
# either don't worry or learn python regular expressions.  They really 
# are fantastic!
def readjob(jobfile):
	job = {}
	re_comment = re.compile(r"\!\*[\s\S]*?\*\!")
	re_array   = re.compile(r"\)\s*,\s*\(")

	# define token types
	tok_table  = r"""\s\!table '(\w+)'\!\s"""
	tok_row    = r"""\s\!row\!\s"""
	tok_array  = r"""\s\w+\s*=\s*\([\s\S]*?\)\s"""
	tok_string = r"""\s\w+\s*=\s*'[\s\S]*?'\s"""
	tok_value  = r"""\s\w+\s*=\s*[^!=\s]*\s"""
	tokens = tok_table  + '|' + \
	         tok_row    + '|' + \
		 tok_array  + '|' + \
		 tok_string + '|' + \
		 tok_value
	re_tokens = re.compile(tokens)

	S = open(jobfile).read()

	# remove comment strings
	S = re_comment.sub('', S)

	# reformat arrays
	S = re_array.sub(',', S)

	# tokenize
	n = 0
	while(1):
		s = re_tokens.search(S[n:])
		if not s:
			break
		token = strip(s.group(0))

		if token[:6] == '!table':
			table = []
			job[s.group(1)] = table
			row = {}
		elif token == '!row!':
			table.append(row)
			row = {}
		else:
			parsevalue(row, token)

		n += s.span()[1] - 1

	return job

def printjob(job):
	tablenames = job.keys()
	tablenames.sort()
	for t in tablenames:
		print '\n\ntable=%s' % t
		print job[t]

#####

def getrowbyname(job_table, antname, indexname='name'):
	for t in job_table:
		if t.has_key(indexname):
			if(t[indexname] == antname):
				return t
	return None

# generate an indexed list of antennas (0-based) and the dictionary to
# go from antenna to index
def obs2antennalist(job_obs):
	antennalist = []
	for jo in job_obs:
		if not jo.has_key('name'):
			continue
		ant = jo['name']
		if ant in antennalist:
			continue
		antennalist.append(ant)
	return antennalist
	
def rev_list(l):
	d = {}
	for i in range(len(l)):
		v = l[i]
		d[v] = i
	return d

def obsrow2config(obsrow):
	config = [ \
			int(obsrow['correl_row']), \
			int(obsrow['freq_row'  ]), \
			int(obsrow['source_row']), \
			int(obsrow['custom_row']) \
	 	 ]
	return config

def generatedatastreamlist():
	dsl = []
	return dsl

# generate time-ordered list of antenna states.  One state per
# distinct mjd at each change in any antenna state
def obs2statelist(job_obs, antenna_index):
	nant = len(antenna_index)

	# generate list of event mjds
	mjds = []
	for jo in job_obs:
		start = parsetime(jo['start'])
		stop  = parsetime(jo['stop'])
		if not start in mjds:
			mjds.append(start)
		if not stop in mjds:
			mjds.append(stop)
	mjds.sort()

	# make empty state structure
	mjd_index = {}
	statelist = []
	for m in mjds:
		mjd_index[m] = len(statelist)
		configs = []
		for i in range(nant):
			configs.append([])
		statelist.append([m, configs])

	# populate state structure
	for jo in job_obs:
		start = parsetime(jo['start'])
		stop  = parsetime(jo['stop'])
		i1 = mjd_index[start]
		i2 = mjd_index[stop]
		antname = jo['name']
		if not antenna_index.has_key(antname):
			continue
		a = antenna_index[antname]
		config = obsrow2config(jo)
		for i in range(i1, i2):
			statelist[i][1][a] = config

	# statelist = [ [mjd, [ [corrow, freqrow, sourcerow, customrow][nAnt] ][nEvent]
	return statelist

# given a list of [ [config, subarray] ] and a subarray, return the config
def findconfig(configlist, subarray):
	for cfg in configlist:
		if len(cfg[1]) > 0:
			if cfg[1][0] in subarray:
				return cfg[0]

	return None

# see if two subarrays are compatible.  If so return union of lists
# else return None
def compare_subarrays(s1, s2):
	# duplicate s1 into t
	t = []
	for s in s1:
		l = []
		t.append(l)
		for e in s:
			l.append(e)
	
	n1 = len(s1)
	n2 = len(s2)
	
	n = [-1]*n2
	
	# loop through s2 determining subarray correspondence
	# populate n[] with mapping from s2 to s1, or -1 if
	# none.
	for i2 in range(n2):
		e2 = s2[i2]
		c = [0]*n1
		for e in e2:
			for i1 in range(n1):
				e1 = s1[i1]
				if e in e1:
					c[i1] += 1
		for i1 in range(n1):
			if c[i1] > 0:
				if n[i2] >= 0:
					return None
				else:
					n[i2] = i1
	
	# look for collisions the other way
	if n2 > 1:
		for i in range(n2-1):
			if n[i] < 0:
				continue
			for j in range(i+1, n2):
				if n[i] == n[j]:
					return None
					
	# looks ok, start populating
	for i2 in range(n2):
		e2 = s2[i2]
		if n[i2] < 0:
			e1 = []
			t.append(e1)
		else:
			e1 = t[n[i2]]
		for e in e2:
			if not e in e1:
				e1.append(e)
	for e in t:
		e.sort()

	return t
			
	
# look through table of subarrays looking for a match to subarray.  If found,
# return the index, otherwise add to table and return new element index
def getsubarray_id(table, subarray, minantennas):
	id = []

	# get members of subarray
	sub = []
	for s in subarray:
		if len(s[1]) >= minantennas:
			sub.append(s[1])
	
	for i in range(len(table)):
		t = compare_subarrays(sub, table[i])
		if t != None:
			table[i] = t
			id.append(i)
	
	if len(id) == 0:
		table.append(sub)
		id.append(len(table)-1)

	return id

def statelist2scanlist(statelist, minantennas, nant):
	subarraylist = []
	scanlist = []
	nstate = len(statelist)-1
	for i in range(nstate):
		t1 = statelist[i][0]
		t2 = statelist[i+1][0]
		dt = t2-t1
		subarrays = []
		ant = 0

		# determine subarrays within scan
		for a in statelist[i][1]:
			if a != []:
				added = False
				for s in subarrays:
					if s[0] == a:
						added = True
						s[1].append(ant)
				if not added:
					subarrays.append([a, [ant]])
			ant += 1

		if len(subarrays) > 0:
			sub_id = getsubarray_id(subarraylist, subarrays,  \
						minantennas)
			scanlist.append([i, i+1, t1, t2, nant, \
				sub_id, subarrays])

	return scanlist, subarraylist

# return intersection of two lists, but return first list if second is empty
def intersection(l1, l2):
	if len(l2) < 1:
		return l1
	inter = []
	for e in l1:
		if e in l2:
			inter.append(e)
	return inter		

def generatesubjoblist(scanlist, subarraylist, job, minsubarraysize):
	subs = [-1]
	job_freq = job['frequency']
	subjobrange = [-1, -1, -1.0, -1.0, subs]
	subjoblist = []
	oldconfig = []
	for i in range(len(scanlist)):
		scan = scanlist[i]
		config = []
		for Y in scan[6]:
			if len(Y[1]) < minsubarraysize:
				continue;
			if multiconfig > 0:
				config.append([Y[0][0], Y[0][3]])
			else:
				config.append([Y[0][0], Y[0][1], Y[0][3]])
		if verbose:
			print scan[6]
			print 'CONFIG =  ', config
		intsubs = intersection(scan[5], subs)
		if (len(intsubs) > 0) and (oldconfig == config):
			subs = intsubs
			subjobrange[1] = i
			subjobrange[3] = scan[3]
		else:
			oldconfig = config
			subs = scan[5]
			subjobrange = [i, i, scan[2], scan[3], subs]
			subjoblist.append(subjobrange)
	if verbose:
		print 'SUBJOBLIST = ', subjoblist

	# Now append actual subarray list for each file index
	for sj in subjoblist:
		sub_id = sj[4][0]	# for now just take the first option
		actualsubarray = []
		subarray = subarraylist[sub_id]
		ls = len(subarray)
		for i in range(ls):
			actualsubarray.append([])
		sj.append(actualsubarray)
		for scan in scanlist[sj[0]:sj[1]+1]:
			for q in scan[6]:
				for a in q[1]:
					for i in range(ls):
						if a in subarray[i] and not a in actualsubarray[i]:
							actualsubarray[i].append(a)
		ss = []
		for a in actualsubarray:
			#if len(a) > minsubarraysize:
			ss.append(a)
		for sss in ss:
			sss.sort()
		sj[5] = ss
							
	return subjoblist
		
# Append another entry on freqlist if not already present.
#
# return index of this setup.
#
def findfreqrowindex(freqlist, frq, bw, sb, os):
	n = len(freqlist)
	for i in range(n):
		f = freqlist[i]
		if f[0:4] == [frq, bw, sb, os]:
			return i
	freqlist.append([frq, bw, sb, os, []])
	return n


# Make single list encompassing all freq/sideband/bw combinations needed
#
# Return in ordered list of:
#	 [ [freq, bw, sideband, oversamp, [pols] ], ... ]
# freq and bw in MHz
# sideband = 'U' or 'L'
# oversamp is integer >= 1
# pols = ['R', 'L'], ['R'], or ['L']
# 
# currently all freq rows must be of same size (ie, same number of active
# record channels)
#
def generatefreqlist(job_freq, setups):
	freqlist = []
	nEnable = 0

	for s in setups:
		job_freq_row = job_freq[s[0]]
		os = 0.5*float(job_freq_row['sample_rate'])/  \
			float(job_freq_row['bandwidth'])
		os = int(os + 0.5)
		decim = os/spectrunc
		if decim == 0:
			decim = 1
		trunc = os/decim
		bw = float(job_freq_row['sample_rate'])/(decim*2.0e6)  # in MHz
		enable = job_freq_row['fft_enable']
		freq   = job_freq_row['base_freq']
		side   = job_freq_row['net_side']
		polar  = job_freq_row['polarization']
		n = len(enable)
		if nEnable == 0:
			nEnable = n;
		else:
			if nEnable != n:
				print "Mixed freq row sizes! -- can't cope!"
				exit(0)
		for i in range(1, n):
			if enable[i] == 'YES':
				frq = float(freq[i])/1.0e6
				if side[i] == '1':
					sb = 'U'
				else:
					sb = 'L'
				pol = polar[i][1]
				freqrowindex = findfreqrowindex(freqlist, \
						frq, bw, sb, os)
				freqrow = freqlist[freqrowindex]
				pollist = freqrow[4]
				if not pol in pollist:
					pollist.append(pol)
			
	return freqlist
	

# go through source list and parse out source names and their parameters.
# return as python list of [name, ra(radians), dec(radians), calcode, qual]
#
def generatesrclist(job_source):
	srclist = []
	for js in job_source:
		srclist.append([ \
			js['name'], \
			RA2radians(js['ra']), \
			Dec2radians(js['dec']), \
			js['calcode'], \
			int(js['qual']) \
		])

	return srclist

# Given a format name and first used track, return the index (0-based) of
# the record channel
#
def track2recChan(formatName, trackNum):
	if formatName[0:4] in ['VLBA', 'MKIV']:
		fanout = int(formatName[6])
		triple = split(formatName[8:], '-')
		nChan = int(triple[1])
		nBit = int(triple[2])
		delta = fanout*nBit*2
		if trackNum < 34:
			if trackNum % 2 == 0:
				return (trackNum-2)/delta
			else:
				return (trackNum+29)/delta
		else:
			if trackNum % 2 == 0:
				return (trackNum+30)/delta
			else:
				return (trackNum+61)/delta
	elif formatName[0:4] == 'MK5B':
		return trackNum
	else:
		return -1

####### Functions to make output DiFX tables #####

def indent21_1(key1, val, i, v):
	out = (key1 % i) + ':'
	n = 20-len(out)
	if n > 0:
		out += ' '*n
	out += (val % v)
	return out

def indent21_2(key1, val, i, j, v):
	out = (key1 % (i, j)) + ':'
	n = 20-len(out)
	if n > 0:
		out += ' '*n
	out += (val % v)
	return out

def indent21_1trunc(key1, val, i, v):
	out = (key1 % i) + ':'
	n = 20-len(out)
	if n > 0:
		out += ' '*n
	if len(out) > 20:
		out = out[:20]
	out += (val % v)
	return out

def indent21_2trunc(key1, val, i, j, v):
	out = (key1 % (i, j)) + ':'
	n = 20-len(out)
	if n > 0:
		out += ' '*n
	if len(out) > 20:
		out = out[:20]
	out += (val % v)
	return out
		
############## Pulsar functions ##################

def isGated(job, config):
	if not job.has_key('gate'):
		return False
	gate = job['gate']
	for g in gate:
		if config[0] == int(g['correl_row']) and \
		   config[1] == int(g['freq_row']) and \
		   config[2] == int(g['source_row']) and \
		   config[3] == int(g['custom_row']):
			return True
	return False

def getPulsars(job, correl_row, freq_row, custom_row):
	if not job.has_key('gate'):
		return []
	gate = job['gate']
	psrs = []
	for g in gate:
		srcId = int(g['source_row'])
		if srcId in psrs:
			continue
		if correl_row == int(g['correl_row']) and \
		   freq_row   == int(g['freq_row']) and \
		   custom_row == int(g['custom_row']):
			psrs.append(srcId)
		
	return psrs

def makepolycofile(filename, gaterow, name):
	st0 = gaterow['start']
	st1 = gaterow['stop']
	t0 = parsetime(st0)
	t1 = parsetime(st1)
	c = []
	for v in gaterow['coefficient']:
		c.append(float(v))
	f = 3600.0
	for i in range(3,len(c)):
		c[i] *= f;
		f *= 60.0
	dm = float(gaterow['dispersion'])
	freq = float(gaterow['refFreq'])*1.0e-6
	dur = ceil((t1-t0)*1440 + 0.5)
	mjd = (t0 + t1)/2.0
	day = st0[7:9] + '-' + st0[4:7] + '-' + st0[2:4]
	x = mjd - int(mjd)
	hr = int(x*24.0)
	x -= hr/24.0
	mi = int(x*1440.0)
	x -= mi/1440.0;
	se = x*86400.0
	ti = '%02d%02d%05.2f' % (hr, mi, se)
	psr = []
	psr.append('%-11s%s  %s   %15.11f    %17.6f  0.000  0.000' % (name, day, ti, mjd, dm))
	psr.append('   %17.6f %17.12f    0  %3d    6 %9.3f 00000  0.0000' % (c[1], c[2], dur, freq))
	psr.append(' %23.16e  %23.16e  %23.16e' % (0.0,  0.0,  c[3]))
	psr.append(' %23.16e  %23.16e  %23.16e' % (c[4], c[5], c[6]))
	out = open(filename, 'w')
	for p in psr:
		out.write(p + '\n')
	out.close()

def makepulsarfile(gate, correl_row, freq_row, custom_row, source_row, filebasein):
	dir = getcwd()

	filebase = split(filebasein, '.')[0]

	psrbase = '%s/%s.%d.%d.%d.%d' % (dir, filebase, correl_row, freq_row, custom_row, source_row)

	filename = psrbase + '.pulsar'

	rows = []
	for i in range(len(gate)):
		g = gate[i]
		if correl_row == int(g['correl_row']) and \
		   freq_row   == int(g['freq_row']) and \
		   custom_row == int(g['custom_row']) and \
		   source_row == int(g['source_row']):
			rows.append(i)
	npoly = len(rows)

	gate_open   = float(gate[rows[0]]['onPhase'][1])
	gate_close  = float(gate[rows[0]]['offPhase'][1])
	gate_open  -= int(gate_open)
	gate_close -= int(gate_close)

	psrtable = []
	psrtable.append('NUM POLYCO FILES:   %d' % npoly)
	for p in range(npoly):
		polycofile = '%s.polyco.%d' % (psrbase, p)
		psrtable.append(indent21_1('POLYCO FILE %d', '%s', \
			p, polycofile))
		psrname = 'psr%d%d%d%d' % (correl_row, freq_row, custom_row, source_row)
		makepolycofile(polycofile, gate[rows[p]], psrname)
	psrtable.append('NUM PULSAR BINS:    2')
	psrtable.append('SCRUNCH OUTPUT:     TRUE')
	if(gate_close < gate_open):
		psrtable.append('BIN PHASE END 0:    %8.6f' % gate_close)
		psrtable.append('BIN WEIGHT 0:       1.0')
		psrtable.append('BIN PHASE END 1:    %8.6f' % gate_open)
		psrtable.append('BIN WEIGHT 1:       0.0')
	else:
		psrtable.append('BIN PHASE END 0:    %8.6f' % gate_open)
		psrtable.append('BIN WEIGHT 0:       0.0')
		psrtable.append('BIN PHASE END 1:    %8.6f' % gate_close)
		psrtable.append('BIN WEIGHT 1:       1.0')

	if len(psrtable) > 0:
		fp = open(filename, "w") 
		for pl in psrtable:
			fp.write(pl+'\n')
		fp.close()
	else:
		system('rm -f %s' % filename)

	return filename

###########################################

def maketelescopetable(job_clock, subarray, antennalist, startmjd):
	tele = []
	nTelescope = len(subarray)
	tele.append("# TELESCOPE TABLE ##!")
	tele.append("TELESCOPE ENTRIES:  %d" % nTelescope)
	for i in range(nTelescope):
		ant_index = subarray[i]
		ant = getrowbyname(job_clock, antennalist[ant_index])
		if ant['name'] != antennalist[ant_index]:
			print 'clock table antennas out of order'
			return None
		delay = float(ant['offset']) * 1.0e6
		rate  = float(ant['rate']) * 1.0e6
		
		# input file references delay to start of obs
		# job script references an arbitrary day
		# adjust the delay so they are compatible
		deltat = ( startmjd - parsetime(ant['time']) )*86400.0
		delay += rate*deltat;
		
		tele.append(indent21_1("TELESCOPE NAME %d", "%s", \
			i, antennalist[ant_index]))
		tele.append(indent21_1("CLOCK DELAY (us) %d", "%s", \
			i, delay))
		tele.append(indent21_1("CLOCK RATE(us/s) %d", "%s", \
			i, rate))

	return tele

def makecommontable(filebase, nAntenna, startmjd, stopmjd):
	dir = getcwd()
	exectime = 86400.0*(stopmjd-startmjd)
	startday = int(startmjd)

	# FIXME! When moving to fractional start time, change below!
	startsec = int((startmjd - startday)*86400.0 + 0.5)
	
	common = []
	common.append("# COMMON SETTINGS ##!")
	common.append("DELAY FILENAME:     %s/%s.delay" % (dir, filebase))
	common.append("UVW FILENAME:       %s/%s.uvw" % (dir, filebase))
	common.append("CORE CONF FILENAME: %s/%s.threads" % (dir, filebase))
	common.append("EXECUTE TIME (SEC): %d" % int(exectime+0.5))
	common.append("START MJD:          %d" % startday)
	common.append("START SECONDS:      %d" % startsec)
	common.append("ACTIVE DATASTREAMS: %d" % nAntenna)
	common.append("ACTIVE BASELINES:   %d" % ( (nAntenna-1)*nAntenna/2 ) )
	common.append("VIS BUFFER LENGTH:  %d" % visbufferlength)
	common.append("OUTPUT FORMAT:      SWIN")
	common.append("OUTPUT FILENAME:    %s/%s.difx" % (dir, filebase))
	return common

def intTime(dt, speedUp):
	granularity = speedUp*0.131072
	nGran = int(dt/granularity + 0.5)
	return granularity*nGran

def makeconfigutationtable(config, nant, job, setups, fftsize, nchan, tint, freqlist, filebase):
	custom = job['custom']
	correl = job['correlator']
	master = job['master']
	job_freq = job['frequency']
	speedUp = master[0]['speed_up']

	minBW = 1e12
	for f in freqlist:
		if f[1] < minBW:
			minBW = f[1]
	minBW *= 1.0e6	# convert to Hz

	# determine oversampling
	osamp = int(job_freq[0]['sample_rate'])/ \
		(2*int(job_freq[0]['bandwidth']))
	decim = osamp/spectrunc
	if decim == 0:
		decim = 1
	trunc = osamp/decim

	if fftsize == 0:
		fftsize = float(correl[config[0]]['fftsize'])
	if nchan == 0:
		fftsize *= trunc
		specavg = float(correl[config[0]]['spect_avg'])
		nchan   = float(correl[config[0]]['fftsize'])/specavg/2
	specavg = int(fftsize/(2*nchan*trunc))
	if specavg*nchan*trunc*2 != fftsize:
		print 'problem with nchan and fftsize'
		exit(0)

	psrs = []
	nConf = 0
	for s in setups:
		psrlist = getPulsars(job, config[0], s[0], s[1])
		if len(psrlist) > 0:
			psrlist.insert(0, -1)
		else:
			psrlist = [-1]
		nConf += len(psrlist)
		psrs.append(psrlist)

	cfg = []
	cfg.append("# CONFIGURATIONS ###!")
	cfg.append("NUM CONFIGURATIONS: %d" % nConf)
	datastreamId = 0
	baselineId = 0

	for setupnum in range(len(setups)):
		s = setups[setupnum]
		for psr in psrs[setupnum]:
			setupname = "FREQ%dCUST%dDOPOL%d" % (s[0], s[1], s[2])
			if psr >= 0:
				setupname += 'PSR%d' % psr
			if tint > 0.0:
				timeavg = tint
			else:
				timeavg = intTime(float(custom[s[1]]['time_avg']), \
					float(speedUp))
			
			# .25 seconds per send
			sendLen = 0.262144
			while sendLen > timeavg:
				sendLen /= 2.0
				
			nBlock = int(2.0*sendLen*minBW*NDataSegment/(decim*fftsize*BufferFactor))
			nn = int(timeavg/sendLen + 0.99)
			if nn == 0:
				nn = 1
			timeavg = sendLen*nn
			
			cfg.append("CONFIG SOURCE:      %s" % setupname)
			cfg.append("INT TIME (SEC):     %f" % timeavg)
			cfg.append("NUM CHANNELS:       %d" % (fftsize/2))
			cfg.append("CHANNELS TO AVERAGE:1")
			cfg.append("OVERSAMPLE FACTOR:  %d" % osamp)
			cfg.append("DECIMATION FACTOR:  %d" % decim)
			cfg.append("BLOCKS PER SEND:    %d" % nBlock)
			cfg.append("GUARD BLOCKS:       1")
			cfg.append("POST-F FRINGE ROT:  FALSE")
			cfg.append("QUAD DELAY INTERP:  TRUE")
			cfg.append("WRITE AUTOCORRS:    TRUE")
			# FIXME -- pulsar
			if psr >= 0:
				psrFile = makepulsarfile(job['gate'], config[0], s[0], s[1], psr, filebase);
				cfg.append("PULSAR BINNING:     TRUE")
				cfg.append("PULSAR CONFIG FILE: %s" % psrFile)
			else:
				cfg.append("PULSAR BINNING:     FALSE")

			nDatastream = 0
			nBaseline = 0
			for j in range(nant):
				cfg.append(indent21_1("DATASTREAM %d INDEX", "%d", \
					j, datastreamId + nDatastream))
				nDatastream += 1
			for j in range(nant*(nant-1)/2):
				cfg.append(indent21_1("BASELINE %d INDEX", "%d", \
					j, baselineId + nBaseline))
				nBaseline += 1
		datastreamId += nDatastream
		baselineId += nBaseline

	return cfg, specavg

def makefreqtable(freqlist):
	frq = []
	l = len(freqlist)
	frq.append("# FREQ TABLE #######!")
	frq.append("FREQ ENTRIES:       %d" % l)
	for i in range(l):
		f = freqlist[i]
		frq.append(indent21_1("FREQ (MHZ) %d", "%10.8f", i, f[0]))
		frq.append(indent21_1("BW (MHZ) %d",   "%10.8f", i, f[1]))
		frq.append(indent21_1("SIDEBAND %d",   "%s",     i, f[2]))
	return frq
				
def makedatastreamtable(subarray, antennalist, config, job, freqlist, setups):
	SA = {'1' : 'U' , '-1' : 'L'}

	dst = []
	nant = len(subarray)
	format = job['format']
	job_obs = job['obs']
	job_freq = job['frequency']
	nfreq = len(freqlist)
	

	dst.append("# DATASTREAM TABLE #!")
	dst.append("DATASTREAM ENTRIES: %d" % (nant*len(setups)) )
	dst.append("DATA BUFFER FACTOR: %d" % BufferFactor)
	dst.append("NUM DATA SEGMENTS:  %d" % NDataSegment)

	for setup in setups:
		job_freq_row = job_freq[setup[0]]
		enable = job_freq_row['fft_enable']
		freq   = job_freq_row['base_freq']
		side   = job_freq_row['net_side']
		polar  = job_freq_row['polarization']

		bw = float(job_freq_row['sample_rate'])/2.0e6	# bw in MHz
		os = 0.5*float(job_freq_row['sample_rate'])/  \
			float(job_freq_row['bandwidth'])
		os = int(os + 0.5)

		fslist = []
		for i in range(len(enable)):
			if enable[i] != 'YES':
				continue
			f = float(freq[i])/1000000.0
			s = SA[side[i]]
			fs = [f, s]
			if fs in fslist:
				continue;
			fslist.append(fs)
		
		for ds_num in range(nant):
			obsrow = getrowbyname(job_obs, antennalist[subarray[ds_num]])
			format_id = int(obsrow['format_row'])
			qbits = int(format[format_id]['sample_bits'])
			fanout = int(format[format_id]['format_mode'][-1])
			format_name = format[format_id]['format_mode'][0:4]
			nIF = 0
			for p in job_freq_row['polarization'][1:]:
				if p[1] != ' ':
					nIF+=1
			tracks = fanout*qbits*nIF
			Mbps =int(job_freq_row['sample_rate'])*nIF*qbits/1000000
			
			if format_name == "VLBA":
				framesize = qbits*nIF*fanout*2520
			else:
				framesize = qbits*nIF*fanout*2500

			trackList = format[format_id]['track']
			

			dst.append("TELESCOPE INDEX:    %d" % ds_num)
			dst.append("TSYS:               0.0")
			dst.append("DATA FORMAT:        %s" % format_name)
			dst.append("QUANTISATION BITS:  %d" % qbits)
			dst.append("DATA FRAME SIZE:    %d" % framesize)
			dst.append("DATA SOURCE:        %s" % "MODULE")
			dst.append("FILTERBANK USED:    FALSE")
			dst.append("NUM FREQS:          %d" % len(fslist))

			format_name += ('1_%d-%d-%d-%d' % (fanout, Mbps, nIF, qbits))

			fq = 0
			for fs in fslist:
				f = fs[0]
				s = fs[1]
				r = findfreqrowindex(freqlist, f, bw, s, os)
				dst.append(indent21_1("FREQ TABLE INDEX %d", \
					"%d", fq, r))
				dst.append(indent21_1("CLK OFFSET %d (us)", \
					"%8.6f", fq, 0.0))
				dst.append(indent21_1("NUM POLS %d", "%d", \
					fq, len(freqlist[r][4])))
				fq += 1

			inputBandList = []
			for i in range(len(enable)):
				if enable[i] != 'YES':
					continue
				f = float(freq[i])/1000000.0
				s = SA[side[i]]
				fs = [f, s]
				index = fslist.index(fs)
				trackNum = int(trackList[i])
				band = track2recChan(format_name, trackNum)
				inputBandList.append([band, polar[i][1], index, trackNum])
			# write input band descriptions in record channel order
			inputBandList.sort()
			last = -1
			for b in inputBandList:
				if b[0] == last:
					print '*** Warning: two INPUT BANDs with same index'
					print 'Did someone forget DISCUPPER in a .fx file?'
				last = b[0]
				dst.append(indent21_1("INPUT BAND %d POL", \
					"%s", b[0], b[1]))
				dst.append(indent21_1("INPUT BAND %d INDEX", \
					"%d", b[0], b[2]))
	
	return dst

# FIXME : handle freq list properly!
def makebaselinetable(job, nant, freqlist, dopolar, setups):
	SA = {'1' : 'U' , '-1' : 'L'}

	job_freq = job['frequency']

	if verbose:
		print 'BL FREQ LIST ',freqlist
	
	blt = []
	blt.append("# BASELINE TABLE ###!")
	blt.append("BASELINE ENTRIES:   %d" % (len(setups)*(nant*(nant-1)/2)) )
	bl_id = 0
	deltaAnt = 0
	for setup in setups:
	  job_freq_row = job_freq[setup[0]]
	  enable = job_freq_row['fft_enable']
	  freq   = job_freq_row['base_freq']
	  side   = job_freq_row['net_side']
	  polar  = job_freq_row['polarization']

	  bw = float(job_freq_row['sample_rate'])/2.0e6 #bw in MHz
	  os = 0.5*float(job_freq_row['sample_rate'])/  \
		float(job_freq_row['bandwidth'])
	  os = int(os + 0.5)
	  fslist = []
	  
	  for i in range(len(enable)):
		if enable[i] != 'YES':
			continue
		f = float(freq[i])/1000000.0
		s = SA[side[i]]
		fs = [f, s]
		if fs in fslist:
			continue;
		else:
			fslist.append(fs)

	  nfreq = len(fslist)
	  
	  for i in range(0, nant-1):
	    for j in range(i+1, nant):
		dsA = i + deltaAnt
		dsB = j + deltaAnt
		blt.append(indent21_1trunc("D/STREAM A INDEX %d", "%d", bl_id, dsA))
		blt.append(indent21_1trunc("D/STREAM B INDEX %d", "%d", bl_id, dsB))
		blt.append(indent21_1("NUM FREQS %d", "%d", bl_id, nfreq))
		ind = 0
		for fq in range(len(fslist)):
			fs = fslist[fq]
			f = fs[0]
			s = fs[1]
			r = findfreqrowindex(freqlist, f, bw, s, os)

			pols = freqlist[r][4]
			npol = len(pols)
			if dopolar:
				npol = npol*npol
			blt.append(indent21_2("POL PRODUCTS %d/%d", "%d", \
				bl_id, fq, npol))
			pol_id = 0

			# generate list of polarization pairs
			polpairs = []

			# first the parallel hands
			for p in range(len(pols)):
				polpairs.append([ind+p, ind+p])

			# then cross hands, if possible
			if dopolar and len(pols) == 2:
				polpairs.append([ind,   ind+1])
				polpairs.append([ind+1, ind  ])
				
			# write out polarization pairs
			pol_id = 0
			for p in polpairs:
				blt.append(indent21_1("D/STREAM A BAND %d", \
					"%d", pol_id, p[0]))
				blt.append(indent21_1("D/STREAM B BAND %d", \
					"%d", pol_id, p[1]))
				pol_id += 1
			ind += len(pols)
		bl_id += 1
	  deltaAnt += nant
	return blt

def zero2oh(str):
	out = ''
	j = 0
	for a in str:
		if a == '-' or a == '+':
			j+=1
		if j == 0 and a == '0':
			out += 'O'
		else:
			out += a

	return out

def makedatatable(mjd0, mjd1, antennalist, subarray, job, nsetups):
	job_tape = job['tape']
	job_rec  = job['recorder']
	data = []
	data.append("# DATA TABLE #######!")
	nant = len(subarray)
	n = 0
	for s in range(nsetups):
		for ant_id in subarray:
			rec = getrowbyname(job_rec, antennalist[ant_id])
			if rec == None:
				print 'Antenna %s not in recorder table' % \
					antennalist[ant_id]
				exit(0)
			taperow = int(rec['tapes_row'])
			vsn = zero2oh(job_tape[taperow]['tape_id'])
			data.append(indent21_1("D/STREAM %d FILES", "%d", n, 1))
			data.append(indent21_2("FILE %d/%d", "%s", n, 0, vsn))
			n += 1
	return data

def mergeflags(flags):
	af = {}
	for f in flags:
		a = f[2]
		if af.has_key(a):
			if f[0] <= af[a][-1][1] + 1.0/86400.0:
				# extend previous flag
				af[a][-1][1] = f[1]
			else:
				af[a].append([f[0], f[1], f[2]])
		else:
			af[a] = [f]
	flags = []
	keys = af.keys()
	keys.sort()
	for key in keys:
		a = af[key]
		for f in a:
			flags.append(f)
	return flags
	

def makeflagtable(scans, subarray, subarray_num):
	flag = []
	flags = []
	for scan in scans:
		if len(scan[6]) <= subarray_num:
			print 'Warning : makeflagtable: subarray_num too big', subarray_num
			continue
		ants = scan[6][subarray_num][1]
		for i in range(len(subarray)):
			a = subarray[i]
			if a not in ants:
				flags.append([scan[2], scan[3], i])

	flags = mergeflags(flags)
	for f in flags:
		flag.append("%12.6f %12.6f %d" % \
			(f[0], f[1], f[2]))
	return flag

def getshelves(antennalist, subarray, job):
	job_tape = job['tape']
	job_rec  = job['recorder']
	data = {}
	nant = len(subarray)
	for ant_id in subarray:
		rec = getrowbyname(job_rec, antennalist[ant_id])
		if rec == None:
			print 'Antenna %s not in recorder table' % \
				antennalist[ant_id]
			exit(0)
		taperow = int(rec['tapes_row'])
		shelf = job_tape[taperow]['shelfLoc']
		if shelf == 'fwd_err':
			shelf = 'None'
		data[ant_id] = shelf
	return data

def makecalctable(scans, subarray, filebase, job, antennalist, srclist, specavg, jobstarttime, jobstoptime, subjob_num, subarray_num, difxversion):
	job_station = job['station']
	job_eop = job['UTC']
	job_corr = job['correlator']
	job_master = job['master']
	job_custom = job['custom']
	job_freq = job['frequency']
	if 'spacecraft' in job:
		job_spacecraft = job['spacecraft']
	else:
		job_spacecraft = []
	calc = []
	mjd0 = scans[0][2]
	start = mjd2calendar(mjd0)
	nant = len(subarray)
	inc = 1

	# get shelf info
	shelves = getshelves(antennalist, subarray, job)

	# determine oversampling
	osamp = int(job_freq[0]['sample_rate'])/ \
		(2*int(job_freq[0]['bandwidth']))
	decim = osamp/spectrunc
	if decim == 0:
		decim = 1
	trunc = osamp/decim

	timeavg = float(job_custom[0]['time_avg'])

	calc.append("JOB ID:             %s" % job_master[0]['job_id'])
	calc.append("JOB START TIME:     %s" % jobstarttime)
	calc.append("JOB STOP TIME:      %s" % jobstoptime)
	calc.append("OBSCODE:            %s" % job_master[0]['obscode'])
	session = job_master[0]['session']
	if len(session) > 0:
		if session[0] != ' ':
			calc.append("SESSION:            %s" % session)
	if difxversion != None:
		calc.append("DIFX VERSION:       %s" % difxversion)
	calc.append("SUBJOB ID:          %d" % subjob_num)
	calc.append("SUBARRAY ID:        %d" % subarray_num)
	calc.append("START MJD:          %12.7f" % mjd0)
	calc.append("START YEAR:         %d" % start[0])
	calc.append("START MONTH:        %d" % start[1])
	calc.append("START DAY:          %d" % start[2])
	calc.append("START HOUR:         %d" % start[3])
	calc.append("START MINUTE:       %d" % start[4])
	calc.append("START SECOND:       %d" % start[5])
	calc.append("INCREMENT (SECS):   %d" % inc)
	calc.append("SPECTRAL AVG:       %d" % specavg)
	if osamp > 1:
		calc.append("OUTPUT CHANNELS:    %f" % (1.0/trunc))
	calc.append("TAPER FUNCTION:     %s" % job_corr[0]['window'])
	calc.append("DELAY FILENAME:     %s.delay" % filebase)
	calc.append("UVW FILENAME:       %s.uvw" % filebase)
	calc.append("RATE FILENAME:      %s.rate" % filebase)
	calc.append("IM FILENAME:        %s.im" % filebase)
		
	calc.append("NUM TELESCOPES:     %d" % nant)

	ant_num = 0
	for ant_id in subarray:
		ant_name = antennalist[ant_id]
		stn = getrowbyname(job_station, ant_name)
		mount = stn['axistype']
		offset = stn['axisoff_x']
		x = stn['x']
		y = stn['y']
		z = stn['z']
		calc.append(indent21_1("TELESCOPE %d NAME", "%s", \
			ant_num, ant_name))
		calc.append(indent21_1("TELESCOPE %d MOUNT", "%s", \
			ant_num, mount))
		calc.append(indent21_1("TELESCOPE %d OFFSET (m)", "%s", \
			ant_num, offset))
		calc.append(indent21_1("TELESCOPE %d X (m)", "%s", \
			ant_num, x))
		calc.append(indent21_1("TELESCOPE %d Y (m)", "%s", \
			ant_num, y))
		calc.append(indent21_1("TELESCOPE %d Z (m)", "%s", \
			ant_num, z))
		calc.append(indent21_1("TELESCOPE %d SHELF", "%s", \
			ant_num, shelves[ant_id]))
		ant_num += 1

	nscan = len(scans)
	calc.append("NUM SCANS:          %d" % nscan)
	scan_num = 0
	for scan in scans:
		scanmjd0 = scan[2]
		scanmjd1 = scan[3]
		dur = int( (scanmjd1 - scanmjd0)*86400.0 + 0.5) / inc
		if scan_num == len(scans)-1:
			dur += 120
		scanstart = int( (scanmjd0 - mjd0)*86400.0 + 0.5) / inc
		config = findconfig(scan[6], subarray)
		corr_id = config[0]
		fq_id = config[1]
		src_id = config[2]
		custom_id = config[3]
		job_freq_row = job_freq[fq_id]
		os = 0.5*float(job_freq_row['sample_rate'])/float(job_freq_row['bandwidth'])
		os = int(os + 0.5)
		if job_corr[corr_id]['polar'] == 'YES':
			dopolar = 1
		else:
			dopolar = 0
		config_name = "FREQ%dCUST%dDOPOL%d" % (fq_id, custom_id, dopolar)
		if isGated(job, config):
			config_name += 'PSR%d' % src_id
		calc.append(indent21_1("SCAN %d POINTS", "%d", \
			scan_num, dur))
		calc.append(indent21_1("SCAN %d START PT", "%d", \
			scan_num, scanstart))
		calc.append(indent21_1("SCAN %d SRC NAME", "%s", \
			scan_num, config_name))
		calc.append(indent21_1("SCAN %d REAL NAME", "%s", \
			scan_num, srclist[src_id][0]))
		calc.append(indent21_1("SCAN %d SRC RA", "%17.15f", \
			scan_num, srclist[src_id][1]))
		calc.append(indent21_1("SCAN %d SRC DEC", "%17.15f", \
			scan_num, srclist[src_id][2]))
		calc.append(indent21_1("SCAN %d CALCODE", "%s", \
			scan_num, srclist[src_id][3]))
		calc.append(indent21_1("SCAN %d QUAL", "%d", \
			scan_num, srclist[src_id][4]))
		scan_num += 1

	neop = len(job_eop)
	if neop > MaxEOP:
		neop = MaxEOP
	calc.append("NUM EOP:              %d" % neop)
	eop_num = 0
	for i in range(neop):
		e = job_eop[i]
		calc.append("EOP %d TIME (mjd):     %f" % \
			(eop_num, parsetime(e['time'])) )
		calc.append("EOP %d TAI_UTC (sec):  %s" % \
			(eop_num, e['taiutc']) )
		calc.append("EOP %d UT1_UTC (sec):  %s" % \
			(eop_num, e['ut1utc']) )
		calc.append("EOP %d XPOLE (arcsec): %s" % \
			(eop_num, e['xpole']) )
		calc.append("EOP %d YPOLE (arcsec): %s" % \
			(eop_num, e['ypole']) )
		eop_num += 1

	spacecraft = {}
	for row in job_spacecraft:
		name = row['spacecraft']
		if not name in spacecraft:
			spacecraft[name] = []
		spacecraft[name].append(row)

	calc.append("NUM SPACECRAFT:     %d" % len(spacecraft))
	n = 0
	for sc in spacecraft:
		calc.append(indent21_1("SPACECRAFT %d NAME", "%s", n, sc))
		calc.append(indent21_1("SPACECRAFT %d ROWS", "%d", n, \
			len(spacecraft[sc])))
		m = 0
		for row in spacecraft[sc]:
			t = parsetime(row['time'])
			orbX = row['orb_x']
			orbY = row['orb_y']
			orbZ = row['orb_z']
			velX = row['vel_x']
			velY = row['vel_y']
			velZ = row['vel_z']
			
			rowData = '%13.8f %s %s %s %s %s %s' % \
				(t, orbX, orbY, orbZ, velX, velY, velZ)
			calc.append(indent21_2("SPACECRAFT %d ROW %d", "%s", \
				n, m, rowData))
			
			m += 1
		n += 1

	
	return calc
	
#**********************************

def processjobfile(job, jobfile, antennalist, fftsize, nchan, tint, minsubarraysize, joblist, difxversion):

	job_master = job['master']
	obscode = job_master[0]['obscode']
	session = job_master[0]['session']
	if len(session) > 0:
		if session[0] != ' ':
			obscode = obscode + session

	# lists imply internal data structures
	if len(antennalist) == 0:
		antennalist = obs2antennalist(job['obs'])
	else:
		alist = []
		Alist = obs2antennalist(job['obs'])
		for a in antennalist:
			if a in Alist:
				alist.append(a)
		antennalist = alist
	antenna_index = rev_list(antennalist)
	nant = len(antennalist)
	statelist = obs2statelist(job['obs'], antenna_index)
	scanlist, subarraylist = statelist2scanlist(statelist, minsubarraysize, nant)

	subjoblist = generatesubjoblist(scanlist, subarraylist, job, minsubarraysize)
	srclist = generatesrclist(job['source'])

	jobstarttime = scanlist[0][2]
	jobstoptime  = scanlist[-1][3]

	if verbose > 1:
		print 'antennalist = ', antennalist
		print 'antenna_index = ', antenna_index
		print 'sources  = ', job['source']

		print '\nstatelist:'
		for s in statelist:
			print s

		print '\nscanlist:'
		for s in scanlist:
			print s

		print '\nsubarraylist:'
		for s in subarraylist:
			print s

		print '\nsubjoblist:'
		for sj in subjoblist:
			print sj
		print ''


	## get down to business

	stump = split(jobfile, '/')[-1][0:-3]

	subjob_num = 0
	for sj in subjoblist:
		scan0  = sj[0]	# first scan in subarray (inclusive)
		scan1  = sj[1]	# last scan in subarray (inclusive)
		mjd0   = sj[2]
		mjd1   = sj[3]
		sub_id = sj[4][0]
		subarrays = sj[5]

		for subarray_num in range(len(subarrays)):
			sub = subarrays[subarray_num]

			if len(sub) == 0:
				continue
		
			# a setup is a combination of freqid and customid
			setups = []
		
			for s in range(scan0, scan1+1):
				config = findconfig(scanlist[s][6], sub)
				if config == None:
					print 'Warning: NULL config for ', scanlist[s][6], sub
					continue
				dopolar = job['correlator'][config[0]]['polar'] == 'YES'
				st = [config[1], config[3]]
				if dopolar:
					st.append(1);
				else:
					st.append(0);
				if not st in setups:
					setups.append(st)

			if verbose:
				print 'setups = ', setups
		
			setupgroups = []
			if multiconfig == 2:
				for s in setups:
					setupgroups.append([s])
			else:
				setupgroups = [setups]
	
			# delete .machines .threads .uvw ...files if they exist
			cmd = '/bin/rm -f %s.???.machines %s.???.threads %s.???.uvw %s.???.rate %s.???.delay %s.???.im' % (stump, stump, stump, stump, stump, stump)
			system(cmd)
			
			for setups in setupgroups:
				filebase = '%s.%03d' % (stump, subjob_num)
				joblist.append([filebase, upper(obscode)])
			
				tables = []
				nant = len(sub)
				config = findconfig(scanlist[scan0][6], sub)
				if config == None:
					print 'Warning: NULL config for ', scanlist[scan0][6], sub
					continue
				dopolar = job['correlator'][config[0]]['polar'] == 'YES'
				freqlist = \
					generatefreqlist(job['frequency'], setups)
				if verbose > 1:
					print 'freqlist = ', freqlist
				tables.append( makecommontable(filebase, nant, \
					mjd0, mjd1) )
				ct, specavg = makeconfigutationtable(config, \
					nant, job, setups, fftsize, nchan, tint, \
					freqlist, filebase)
				tables.append(ct);
				tables.append( makefreqtable(freqlist) )
				tables.append( maketelescopetable(job['clock'], \
					sub, antennalist, mjd0) )
				tables.append( makedatastreamtable(sub, antennalist, \
					config, job, freqlist, setups) )
				tables.append( makebaselinetable(job, nant, \
					freqlist, dopolar, setups) )
				tables.append( makedatatable(mjd0, mjd1, antennalist, \
					sub, job, len(setups)) )
				filename = '%s.input' % filebase
				fp = open(filename, "w")
				for t in tables:
					for r in t:
						fp.write(r+'\n')
					fp.write('\n')
				fp.close()

				# do the calc thing
				calctable = makecalctable(scanlist[scan0:scan1+1], \
						sub, filebase, job, antennalist, \
						srclist, specavg, jobstarttime, \
						jobstoptime, subjob_num,subarray_num, difxversion)
				filename = '%s.calc' % filebase
				fp = open(filename, "w")
				for c in calctable:
					fp.write(c+'\n')
				fp.close()
				
				# make subarray flags
				filename = '%s.flag' % filebase
				flagtable = makeflagtable(scanlist[scan0:scan1+1], \
						sub, subarray_num)
				if len(flagtable) > 0:
					fp = open(filename, "w") 
					fp.write("%d\n" % len(flagtable))
					for f in flagtable:
						fp.write(f+'\n')
					fp.close()
				else:
					system('rm -f %s' % filename)

				subjob_num += 1

#############

def merge(jobs):
	rankList = []

	jobIds = []
	for j in jobs[1:]:
		jobIds.append(int(j['master'][0]['job_id']))
	
	# generate sort key
	for i in range(1,len(jobs)):
		# keep popping of jobs until the list is empty
		j = jobs.pop()
		fmt = j['format'][0]
		if fmt['barrel_roll'] == 'DISCUPPER':
			R = '1'
		else:
			R = '0'
		N = int(fmt['track'][1])
		if N > 33:
			N += 200
		if N % 2 == 1:
			N += 100
		rankList.append(["%c%03d" % (R, N), j])
	rankList.sort()
	# push only the master job back onto the list
	jobs.append(rankList[0][1])
	freq1 = jobs[1]['frequency']
	form1 = jobs[1]['format']
	print 'Merging jobs ', jobIds, 'into one job: ',  \
		int(jobs[1]['master'][0]['job_id'])
	nFreq1 = len(freq1)
	nForm1 = len(form1)
	# the first ranked job will be the master.  Append other parallel
	# jobs to this one.
	for g in rankList[1:]:
		freq2 = g[1]['frequency']
		form2 = g[1]['format']
		for i in range(nFreq1):
			if form2[0]['barrel_roll'] == 'DISCUPPER':
				delta = 32
			else:
				delta = 0
			for v in freq2[i]['fft_enable'][1:]:
				freq1[i]['fft_enable'].append(v)
			for v in freq2[i]['base_freq'][1:]:
				freq1[i]['base_freq'].append(v)
			for v in freq2[i]['net_side'][1:]:
				freq1[i]['net_side'].append(v)
			for v in freq2[i]['polarization'][1:]:
				freq1[i]['polarization'].append(v)
		for i in range(nForm1):
			for v in form2[i]['track'][1:]:
				if v != '-1':
					newtrack = delta + int(v)
				else:
					newtrack = int(v)
				form1[i]['track'].append('%s' % newtrack)
	

# argument is list of ['filename', job]
def combinejobs(jobs):
	N = len(jobs)
	if N < 2:
		return
	for i in range(1, N):
		if len(jobs[i]) < 2:
			continue
		j1 = jobs[i][1]
		m1 = j1['master'][0]
		o1 = j1['obs']
		s1 = j1['source']
		f1 = j1['frequency']
		for j in range(0, i):
			if len(jobs[j]) < 2:
				continue
			j2 = jobs[j][1]
			m2 = j2['master'][0]
			o2 = j2['obs']
			s2 = j2['source']
			f2 = j2['frequency']
			ok = (o1 == o2 and s1 == s2 and not f1 == f2)
			for k in m2.keys():
				if k == 'job_id':
					continue
				if m1[k] != m2[k]:
					ok = False
			if ok:
				# jobs must match.  queue for combination
				jobs[j].append(jobs[i].pop())
	for j in jobs:
		if len(j) > 2:
			merge(j)


def dupsched(job, masterant):
	obs = job['obs']
	ants = []
	masterobs = []
	for row in obs:
		ant = row['name']
		if ant == masterant:
			masterobs.append(row)
		if not ant in ants:
			ants.append(ant)
	obs = []
	for ant in ants:
		for row in masterobs:
			r = {}
			for k in row.keys():
				if k == 'name':
					r['name'] = ant
				else:
					r[k] = row[k]
			obs.append(r)
	job['obs'] = obs

#############

if len(argv) < 2:
	usage()
else:
	antennalist = []
	fftsize = 0
	nchan = 0
	tint = 0.0
	verbose = 0
	minsubarraysize = 3
	files = []
	masterant = ''
	difxversion = getenv('DIFX_VERSION')
	if difxversion == None:
		print 'Warning: DIFX_VERSION env. var. not defined.'
	for arg in argv[1:]:
		kv = split(arg, '=')
		if len(kv) == 2:
			if kv[0] == 'A':
				ants = split(kv[1], ',')
				for a in ants:
					antennalist.append(a)
			elif kv[0] == 'M':
				masterant = kv[1]
			elif kv[0] == 'fftsize':
				fftsize = int(kv[1])
			elif kv[0] == 'nchan':
				nchan = int(kv[1])
			elif kv[0] == 'tint':
				tint = float(kv[1])
			elif kv[0] == 'spectrunc':
				spectrunc = int(kv[1])
			elif kv[0] == 'minsub':
				minsubarraysize = float(kv[1])
			elif kv[0] == 'vb':
				visbufferlength = float(kv[1])
		elif arg == '-h' or arg == '--help':
			usage()
		elif arg == '-v' or arg == '--verbose':
			verbose = verbose + 1
		elif arg == '-s' or arg == '--single-config':
			multiconfig = 0
		elif arg == '-m' or arg == '--multi-config':
			multiconfig = 0
		elif arg == '-p' or arg == '--multi-pass':
			multiconfig = 2
		elif len(kv) == 1:
			files.append([arg])
		else:
			print 'What is %s?' % arg
			exit(0)

	if spectrunc not in [1,2,4,8,16]:
		print 'spectrunc must be one of 1, 2, 4, 8, 16'
		exit(0)

	if len(antennalist) > 0 and len(antennalist) < minsubarraysize:
		minsubarraysize = len(antennalist)
		print 'min subarray size reduced to ', minsubarraysize
			
	if getenv('DIFX_GROUP_ID'):
		umask(2)

	print 'Processing files : ', files

	# read jobs
	for file in files:
		job = readjob(file[0])
		# dup master antenna's schedule to other ants
		if masterant != '':
			dupsched(job, masterant)
		file.append(job)


	# combine jobs if possible
	combinejobs(files)
	# process jobs
	joblist = []
	for file in files:
		if len(file) == 2:
			processjobfile(file[1], file[0], antennalist, \
				fftsize, nchan, tint, minsubarraysize, \
				joblist, difxversion)
