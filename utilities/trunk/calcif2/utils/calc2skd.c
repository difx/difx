/***************************************************************************
 *   Copyright (C) 2013 by Walter Brisken                                  *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
//===========================================================================
// SVN properties (DO NOT CHANGE)
//
// $Id: calc2skd.c 5092 2013-01-01 17:47:42Z WalterBrisken $
// $HeadURL: $
// $LastChangedRevision: 5092 $
// $Author: WalterBrisken $
// $LastChangedDate: 2013-01-01 10:47:42 -0700 (Tue, 01 Jan 2013) $
//
//============================================================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <fcntl.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <glob.h>
#include <difxio.h>

#define MAX_FILES	2048

const char program[] = "calc2skd";
const char author[]  = "Walter Brisken <wbrisken@nrao.edu>";
const char version[] = "0.1";
const char verdate[] = "20130301";


typedef struct
{
	int verbose;
	int overrideVersion;
	int force;
	int doall;
	int nFile;
	char *files[MAX_FILES];
} CommandLineOptions;

typedef struct
{
	char name[20];
	double X, Y, Z;
} BlokqAntenna;

/* warning: can modify s! */
int d2s(double *x, char *s)
{
	int i;

	for(i = 0; s[i]; ++i)
	{
		if(s[i] == 'D')
		{
			s[i] = 'e';
			break;
		}
	}
	return sscanf(s, "%lf", x);
}

static void deleteBlokqAntennas(BlokqAntenna *b)
{
	if(b)
	{
		free(b);
	}
}

static BlokqAntenna *loadBlokqAntennas(const char *filename, int verbose)
{
	const int MaxBlokqAntennas = 500;
	const int MaxLineSize = 500;
	BlokqAntenna *b;
	FILE *in;
	int n = 0;
	char line[MaxLineSize+1];

	if(verbose > 0)
	{
		printf("Loading blokq.dat:\n");
	}

	in = fopen(filename, "r");
	if(!in)
	{
		fprintf(stderr, "Error: cannot open %s for read\n", filename);

		return 0;
	}

	b = (BlokqAntenna *)calloc(MaxBlokqAntennas+1, sizeof(BlokqAntenna));

	for(;;)
	{
		char *rv;
		char a0[21], a1[21], a2[21], a3[21], a7[21];
		int a4;
		float a5, a6;
		int na;
		int i;

		rv = fgets(line, MaxLineSize, in);
		if(!rv)
		{
			break;
		}
		for(i = 0; line[i]; ++i)
		{
			if(line[i] == '$')
			{
				line[i] = 0;
				break;
			}
		}
		na = sscanf(line, "%20s%20s%20s%20s%d%f%f%20s", a0, a1, a2, a3, &a4, &a5, &a6, a7);
		if(na == 8)
		{
			if(d2s(&(b[n].X), a1) && d2s(&(b[n].Y), a2) && d2s(&(b[n].Z), a3))
			{
				double R;

				R = sqrt(b[n].X*b[n].X + b[n].Y*b[n].Y + b[n].Z*b[n].Z);
				if(R > 5000000.0)
				{
					if(verbose > 1)
					{
						printf("Antenna: %s at %f %f %f\n", a0, b[n].X, b[n].Y, b[n].Z);
					}

					strcpy(b[n].name, a0);
					++n;
					if(n >= MaxBlokqAntennas)
					{
						fprintf(stderr, "Error: too many antennas in blokq.dat\n");

						fclose(in);
						deleteBlokqAntennas(b);
						
						return 0;
					}
				}
			}
		}
	}

	if(verbose > 0)
	{
		printf("%d antennas loaded\n", n);
	}

	fclose(in);

	return b;
}

static const char *findBlokqAntenna(const BlokqAntenna *B, double X, double Y, double Z)
{
	int i;

	for(i = 0; B[i].name[0]; ++i)
	{
		double dX, dY, dZ, R;
		
		dX = X - B[i].X;
		dY = Y - B[i].Y;
		dZ = Z - B[i].Z;

		R = sqrt(dX*dX + dY*dY + dZ*dZ);

		if(R < 25.0)
		{
			return B[i].name;
		}
	}

	return 0;
}

static void usage()
{
	fprintf(stderr, "%s ver. %s  %s  %s\n\n", program, version, author, verdate);
	fprintf(stderr, "A program to calculate skd files from DiFX .calc files.\n\n");
	fprintf(stderr, "Usage : %s [options] { <calc file> | -a }\n\n", program);
	fprintf(stderr, "<calc file> should be a '.calc' file as generated by vex2difx.\n\n");
	fprintf(stderr, "options can include:\n");
	fprintf(stderr, "  --help\n");
	fprintf(stderr, "  -h                      Print this help and quit\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "  --verbose\n");
	fprintf(stderr, "  -v                      Be more verbose in operation\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "  --quiet\n");
	fprintf(stderr, "  -q                      Be less verbose in operation\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "  --force\n");
	fprintf(stderr, "  -f                      Force recalc\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "  --all\n");
	fprintf(stderr, "  -a                      Do all calc files found\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "  --override-version      Ignore difx versions\n");
	fprintf(stderr, "\n");
}


static void deleteCommandLineOptions(CommandLineOptions *opts)
{
	int i;

	if(!opts)
	{
		return;
	}
	for(i = 0; i < opts->nFile; ++i)
	{
		free(opts->files[i]);
	}

	free(opts);
}

static CommandLineOptions *newCommandLineOptions(int argc, char **argv)
{
	CommandLineOptions *opts;
	glob_t globbuf;
	int i;
	int die = 0;

	opts = (CommandLineOptions *)calloc(1, sizeof(CommandLineOptions));

	for(i = 1; i < argc; ++i)
	{
		if(argv[i][0] == '-')
		{
			if(strcmp(argv[i], "-v") == 0 ||
			   strcmp(argv[i], "--verbose") == 0)
			{
				++opts->verbose;
			}
			else if(strcmp(argv[i], "-q") == 0 ||
			   strcmp(argv[i], "--quiet") == 0)
			{
				--opts->verbose;
			}
			else if(strcmp(argv[i], "-f") == 0 ||
				strcmp(argv[i], "--force") == 0)
			{
				++opts->force;
			}
			else if(strcmp(argv[i], "-a") == 0 ||
			        strcmp(argv[i], "--all") == 0)
			{
				opts->doall = 1;
			}
			else if(strcmp(argv[i], "-h") == 0 ||
				strcmp(argv[i], "--help") == 0)
			{
				usage();
				deleteCommandLineOptions(opts);
				
				return 0;
			}
			else if(strcmp(argv[i], "--override-version") == 0)
			{
				opts->overrideVersion = 1;
			}
			else if(argv[i][0] == '-')
			{
				printf("Error: calc2skd: Illegal option : %s\n", argv[i]);
				++die;
			}
		}
		else
		{
			opts->files[opts->nFile] = strdup(argv[i]);
			opts->nFile++;
			if(opts->nFile >= MAX_FILES)
			{
				fprintf(stderr, "Error: calc2skd: Too many files (%d max)\n", MAX_FILES);
				++die;
			}
		}
	}

	if(opts->doall == 0 && opts->nFile == 0 && !die)
	{
		fprintf(stderr, "Error: calc2skd: No input files!\n");
		++die;
	}

	if(opts->nFile > 0 && opts->doall)
	{
		fprintf(stderr, "Error: calc2skd: Option '--all' provided with files!\n");
		++die;
	}
	else if(opts->doall > 0)
	{
		glob("*.calc", 0, 0, &globbuf);
		opts->nFile = globbuf.gl_pathc;
		if(opts->nFile >= MAX_FILES)
		{
			fprintf(stderr, "Error: calc2skd: Too many files (%d max)\n", MAX_FILES);
			++die;
		}
		else if(opts->nFile <= 0)
		{
			fprintf(stderr, "Error: calc2skd: No .calc files found.  Hint: Did you run vex2difx yet???\n");
			++die;
		}
		for(i = 0; i < opts->nFile; ++i)
		{
			opts->files[i] = strdup(globbuf.gl_pathv[i]);
		}
		globfree(&globbuf);
	}

	if(die)
	{
		if(die > 1)
		{
			fprintf(stderr, "calc2skd quitting. (%d errors)\n", die);
		}
		else
		{
			fprintf(stderr, "calc2skd quitting.\n");
		}
		fprintf(stderr, "Use -h option for calc2skd help.\n");
		deleteCommandLineOptions(opts);

		return 0;
	}

	return opts;
}

/* return 1 if f2 exists and is older than f1 */
static int skipFile(const char *f1, const char *f2)
{
	struct stat s1, s2;
	int r1, r2;

	r2 = stat(f2, &s2);
	if(r2 != 0)
	{
		return 0;
	}
	r1 = stat(f1, &s1);
	if(r1 != 0)
	{
		return 0;
	}

	if(s2.st_mtime > s1.st_mtime)
	{
		return 1;
	}

	return 0;
}

void stringify60(double x, char *out)
{
	char sign = ' ';
	int d, m;
	double s;

	if(x < 0)
	{
		x = -x;
		sign = '-';
	}

	d = (int)x;
	x -= d;
	x *= 60.0;
	m = (int)x;
	x -= m;
	x *= 60.0;
	s = x;

	sprintf(out, "%c%02d %02d %11.8f", sign, d, m, s);
}

/* Note: for now just assign A, B, ... (except G).  Could be fancier later if desired */
static void genAntennaCodes(const DifxInput *D, char antennaCodes[25])
{
	int a;
	char letter = 'A';

	for(a = 0; a < 25; ++a)
	{
		antennaCodes[a] = ' ';
	}

	for(a = 0; a < D->nAntenna; ++a)
	{
		antennaCodes[a] = letter;
		++letter;
		if(letter == 'G')	/* reserved for geocenter */
		{
			++letter;
		}
	}
}

static int mjd2yyddd(int mjd)
{
	const long long mjdAtUnix0 = 40587LL;
	time_t t;
	struct tm tt;

	t = (mjd-mjdAtUnix0)*86400LL;
	gmtime_r(&t, &tt);

	return 1000*(tt.tm_year % 100) + tt.tm_yday + 1;
}

static int sec2hhmmss(int seconds)
{
	int h, m, s;

	s = seconds % 60;
	seconds /= 60;
	m = seconds % 60;
	seconds /= 60;
	h = seconds;

	return 10000*h + 100*m + s;
}

static void sec2colons(char *timeStr, int seconds)
{
	int h, m, s;

	s = seconds % 60;
	seconds /= 60;
	m = seconds % 60;
	seconds /= 60;
	h = seconds;

	sprintf(timeStr, "%02d:%02d:%02d", h, m, s);
}

static void mjd2slashes(char *dateStr, int mjd)
{
	const long long mjdAtUnix0 = 40587LL;
	time_t t;
	struct tm tt;

	t = (mjd-mjdAtUnix0)*86400LL;
	gmtime_r(&t, &tt);

	sprintf(dateStr, "%04d/%02d/%02d", tt.tm_year+1900, tt.tm_mon+1, tt.tm_mday);
}

static void difx2skd(const DifxInput *D, const BlokqAntenna *B, int sourceId, const char *skdFile)
{
	FILE *out;
	int a, s;
	char raStr[32], decStr[32];
	char antennaCodes[25];

	if(D->nAntenna > 25)
	{
		fprintf(stderr, "Error: cannot handle more than 25 antennas.  %d desired.\n", D->nAntenna);

		return;
	}

	genAntennaCodes(D, antennaCodes);

	out = fopen(skdFile, "w");

	if(!out)
	{
		fprintf(stderr, "Error: cannot open %s for write.\n", skdFile);

		return;
	}

	fprintf(out, "$CLOCK\n");
	fprintf(out, " GEOCENTR      0.0      0.0      2013001000000\n");
	for(a = 0; a < D->nAntenna; ++a)
	{
		const char *blokqName;

		blokqName = findBlokqAntenna(B, D->antenna[a].X, D->antenna[a].Y, D->antenna[a].Z);
		if(!blokqName)
		{
			fclose(out);

			fprintf(stderr, "Error: antenna %s not found by coordinate in blokq.dat\n", D->antenna[a].name);

			return;
		}

		fprintf(out, " %-8s      0.0      0.0      2013001000000\n", blokqName);
	}

	fprintf(out, "$SOURCES\n");
	for(s = 0; s < D->nSource; ++s)
	{
		stringify60(D->source->ra*12.0/M_PI, raStr);
		stringify60(D->source->dec*180.0/M_PI, decStr);
		fprintf(out, " %-8s $        %18s %18s 2000.0 0.0\n", D->source[s].name, raStr, decStr);
	}

	fprintf(out, "$STATIONS\n");
	fprintf(out, "A  G  GEOCENTR AZEL 0.00000 180.0  0   95.0  625.0 180.0  0    6.0   88.0  11.0\n");
	for(a = 0; a < D->nAntenna; ++a)
	{
		const char *blokqName;

		blokqName = findBlokqAntenna(B, D->antenna[a].X, D->antenna[a].Y, D->antenna[a].Z);

		fprintf(out, "A  %c %-8s %s %7.5f  90.0  0  270.0  810.0  30.0  0    2.3   88.0  25.0 %2s %2s\n", antennaCodes[a], blokqName, antennaMountTypeNames[D->antenna[a].mount], D->antenna[a].offset[0], D->antenna[a].name, D->antenna[a].name);
	}
	fprintf(out, "P  GC GEOCENTR        +0.00000       +0.00000       +0.00000   00000000   0.0     0.0\n");
	for(a = 0; a < D->nAntenna; ++a)
	{
		const char *blokqName;

		blokqName = findBlokqAntenna(B, D->antenna[a].X, D->antenna[a].Y, D->antenna[a].Z);
		fprintf(out, "P  %2s %-8s  %15.5f %15.5f %15.5f\n", D->antenna[a].name, blokqName, D->antenna[a].X, D->antenna[a].Y, D->antenna[a].Z);
	}
	
	fprintf(out, "$CODES\n");
	fprintf(out, "F CDP-TT   TT GEOCENTR");
	for(a = 0; a < D->nAntenna; ++a)
	{
		fprintf(out, " %8s", D->antenna[a].name);
	}
	fprintf(out, "\n");
	fprintf(out, "C TT X  8194.99  10000.0    1 K4         8.00 1(1)\n");

	fprintf(out, "$SKED\n");
	for(s = 0; s < D->nScan; ++s)
	{
		const int dt = 120;
		const int dt2 = 24;
		int day, seconds, nTime;
		int i;

		if(D->scan[s].pointingCentreSrc != sourceId)
		{
			continue;
		}

		day = (int)(D->scan[s].mjdStart);
		seconds = dt*(int)((D->scan[s].mjdStart - day)*(86400.0/dt));
		nTime = ((int)((D->scan[s].mjdEnd - day)*(86400.0/dt)+1) - (int)((D->scan[s].mjdStart - day)*(86400.0/dt)))*dt/dt2 + 1;

		for(i = 0; i < nTime; ++i)
		{
			fprintf(out, "%-8s 0 TT PREOB %05d%06d 0 MIDOB 0 POSTOB G-", D->source[D->scan[s].pointingCentreSrc].name, mjd2yyddd(day), sec2hhmmss(seconds));
			seconds += dt2;
			if(seconds >= 86400.0)
			{
				seconds -= 86400.0;
				++day;
			}

			for(a = 0; a < D->nAntenna; ++a)
			{
				fprintf(out, "%c-", antennaCodes[a]);
			}
			fprintf(out, "\n");
		}
	}

	fclose(out);
}

static void difx2xyz(DifxSpacecraft *S, const char *xyzFile)
{
	FILE *out;
	int i;

	out = fopen(xyzFile, "w");
	if(!out)
	{
		fprintf(stderr, "Error: cannot open %s for write.\n", xyzFile);

		return;
	}

	for(i = 0; i < S->nPoint; ++i)
	{
		char dateStr[32];
		char timeStr[32];

		sec2colons(timeStr, (int)(S->pos[i].fracDay*86400.0+0.001));
		mjd2slashes(dateStr, S->pos[i].mjd);

		fprintf(out, "%s %s %18.10Lf %18.10Lf %18.10Lf %18.10Lf %18.10Lf %18.10Lf\n", dateStr, timeStr, S->pos[i].X/1000.0, S->pos[i].Y/1000.0, S->pos[i].Z/1000.0, S->pos[i].dX, S->pos[i].dY, S->pos[i].dZ);
	}

	fclose(out);
}

static int calc2skd(const char *prefix, const BlokqAntenna *B, const CommandLineOptions *opts)
{
	DifxInput *D;
	FILE *in;
	char fn[DIFXIO_FILENAME_LENGTH];
	char skdFile[DIFXIO_FILENAME_LENGTH];
	int v;
	const char *difxVersion;
	
	difxVersion = getenv("DIFX_VERSION");

	v = snprintf(fn, DIFXIO_FILENAME_LENGTH, "%s.calc", prefix);
	if(v >= DIFXIO_FILENAME_LENGTH)
	{
		fprintf(stderr, "Error: filename %s.calc is too long (max %d chars)\n", prefix, DIFXIO_FILENAME_LENGTH-1);

		exit(EXIT_FAILURE);
	}
	in = fopen(fn, "r");
	if(!in)
	{
		fprintf(stderr, "File %s not found or cannot be opened.  Quitting.\n", fn);

		return -1;
	}
	else
	{
		fclose(in);
	}

	D = loadDifxCalc(prefix);

	if(D == 0)
	{
		fprintf(stderr, "Error: loadDifxCalc(\"%s\") returned 0\n", prefix);

		return -1;
	}

	if(opts->force == 0 && skipFile(D->job->calcFile, skdFile))
	{
		printf("Skipping %s due to file ages.\n", prefix);
		deleteDifxInput(D);

		return 0;
	}

	D = updateDifxInput(D);
	
	if(D)
	{
		int sourceId;
		int spacecraftId;

		if(difxVersion && D->job->difxVersion[0])
		{
			if(strncmp(difxVersion, D->job->difxVersion, DIFXIO_VERSION_LENGTH-1))
			{
				printf("Attempting to run calc2skd from version %s on a job make for version %s\n", difxVersion, D->job->difxVersion);
				if(opts->overrideVersion)
				{
					fprintf(stderr, "Continuing because of --override-version\n");
				}
				else
				{
					fprintf(stderr, "calc2skd won't run on mismatched version without --override-version.\n");
					deleteDifxInput(D);

					return -1;
				}
			}
		}
		else if(!D->job->difxVersion[0])
		{
			printf("Warning: calc2skd: working on unversioned job\n");
		}

		for(sourceId = 0; sourceId < D->nSource; ++sourceId)
		{
			v = snprintf(skdFile, DIFXIO_FILENAME_LENGTH, "%s.%s.skd", prefix, D->source[sourceId].name);
			if(v >= DIFXIO_FILENAME_LENGTH)
			{
				fprintf(stderr, "Error: filename %s.%s.skd is too long (max %d chars)\n", prefix, D->source[sourceId].name, DIFXIO_FILENAME_LENGTH-1);

				exit(EXIT_FAILURE);
			}
			difx2skd(D, B, sourceId, skdFile);
		}

		for(spacecraftId = 0; spacecraftId < D->nSpacecraft; ++spacecraftId)
		{
			char xyzFile[DIFXIO_FILENAME_LENGTH];

			v = snprintf(xyzFile, DIFXIO_FILENAME_LENGTH, "%s.%s.xyz", prefix, D->spacecraft[spacecraftId].name);
			if(v >= DIFXIO_FILENAME_LENGTH)
			{
				fprintf(stderr, "Error: filename %s.%s.xyz is too long (max %d chars)\n", prefix, D->spacecraft[spacecraftId].name, DIFXIO_FILENAME_LENGTH-1);
			}

			difx2xyz(D->spacecraft + spacecraftId, xyzFile);
		}

		deleteDifxInput(D);

		return 0;
	}
	else
	{
		return -1;
	}
}

int run(CommandLineOptions *opts)
{
	BlokqAntenna *B;
	int i;

	if(getenv("DIFX_GROUP_ID"))
	{
		umask(2);
	}

	if(opts == 0)
	{
		return EXIT_FAILURE;
	}

	B = loadBlokqAntennas(getenv("BLOKQ"), opts->verbose);
	if(!B)
	{
		fprintf(stderr, "Error: cannot load blokq.dat.  Make sure env var BLOKQ is set to point to this file\n");

		return EXIT_FAILURE;
	}

	for(i = 0; i < opts->nFile; ++i)
	{
		int l;

		l = strlen(opts->files[i]);
		if(l > 6)
		{
			if(strcmp(opts->files[i]+l-6, ".input") == 0)
			{
				opts->files[i][l-6] = 0;
			}
			else if(strcmp(opts->files[i]+l-5, ".calc") == 0)
			{
				opts->files[i][l-5] = 0;
			}
		}
		if(opts->verbose >= 0)
		{
			printf("Processing file %d/%d = %s\n", i+1, opts->nFile, opts->files[i]);
		}
		calc2skd(opts->files[i], B, opts);
	}
	
	deleteBlokqAntennas(B);

	return EXIT_SUCCESS;
}

int main(int argc, char **argv)
{
	int status;
	CommandLineOptions *opts;

	opts = newCommandLineOptions(argc, argv);

	status = run(opts);

	deleteCommandLineOptions(opts);

	return status;
}
